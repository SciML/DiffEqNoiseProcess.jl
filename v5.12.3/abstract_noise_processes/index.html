<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Abstract Noise Processes · DiffEqNoiseProcess.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://noise.sciml.ai/stable/abstract_noise_processes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DiffEqNoiseProcess.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffEqNoiseProcess.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../noise_processes/">Classic Noise Processes</a></li><li class="is-active"><a class="tocitem" href>Abstract Noise Processes</a><ul class="internal"><li><a class="tocitem" href="#The-Standard-AbstractNoiseProcess"><span>The Standard <code>AbstractNoiseProcess</code></span></a></li><li><a class="tocitem" href="#Alternative-AbstractNoiseProcess-Types"><span>Alternative <code>AbstractNoiseProcess</code> Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Abstract Noise Processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Abstract Noise Processes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/master/docs/src/abstract_noise_processes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Abstract-Noise-Processes"><a class="docs-heading-anchor" href="#Abstract-Noise-Processes">Abstract Noise Processes</a><a id="Abstract-Noise-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Noise-Processes" title="Permalink"></a></h1><p>In addition to the <code>NoiseProcess</code> type, more general <code>AbstractNoiseProcess</code>es are defined. The <code>NoiseGrid</code> allows you to define a noise process from a set of pre-calculated points (the &quot;normal&quot; way). The <code>NoiseApproximation</code> allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations.</p><p>The <code>NoiseWrapper</code> allows one to wrap a <code>NoiseProcess</code> from a previous simulation to re-use it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example solving with a smaller <code>dt</code>) in a distributionally-exact manner. It is demonstrated how the <code>NoiseWrapper</code> can be used to wrap the <code>NoiseProcess</code> of one SDE/RODE solution in order to re-use the same noise process in another simulation.</p><p>The <code>VirtualBrownianTree</code> allows one to trade speed for O(1) memory usage. Instead of storing Brownian motion increments, the <code>VirtualBrownianTree</code> samples recursively from the midpoint <code>tmid</code> of Brownian bridges, using a splittable PRNG. The recursion terminates when the query time agrees within some tolerance with <code>tmid</code> or when the maximum depth of the tree is reached.</p><p>Lastly, the <code>NoiseFunction</code> allows you to use any function of time as the noise process. Together, this functionality allows you to define any colored noise process and use this efficiently and accurately in your simulations.</p><h2 id="The-Standard-AbstractNoiseProcess"><a class="docs-heading-anchor" href="#The-Standard-AbstractNoiseProcess">The Standard <code>AbstractNoiseProcess</code></a><a id="The-Standard-AbstractNoiseProcess-1"></a><a class="docs-heading-anchor-permalink" href="#The-Standard-AbstractNoiseProcess" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseProcess" href="#DiffEqNoiseProcess.NoiseProcess"><code>DiffEqNoiseProcess.NoiseProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NoiseProcess{T,N,Tt,T2,T3,ZType,F,F2,inplace,S1,S2,RSWM,C,RNGType} &lt;: {T,N,Vector{T2},inplace}</code></pre><p>A <code>NoiseProcess</code> is a type defined as:</p><pre><code class="language-julia hljs">NoiseProcess(t0,W0,Z0,dist,bridge;
             iip=SciMLBase.isinplace(dist,3),
             rswm = RSWM(),save_everystep=true,
             rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
             reset = true, reseed = true)</code></pre><ul><li><code>t0</code> is the first timepoint</li><li><code>W0</code> is the first value of the process.</li><li><code>Z0</code> is the first value of the pseudo-process. This is necessary for higher order algorithms. If it&#39;s not needed, set to <code>nothing</code>.</li><li><code>dist</code> the distribution for the steps over time.</li><li><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</li><li><code>save_everystep</code> whether to save every step of the Brownian timeseries.</li><li><code>rng</code> the local RNG used for generating the random numbers.</li><li><code>reset</code> whether to reset the process with each solve.</li><li><code>reseed</code> whether to reseed the process with each solve.</li></ul><p>The signature for the <code>dist</code> is</p><pre><code class="language-julia hljs">dist!(rand_vec,W,dt,rng)</code></pre><p>for inplace functions, and</p><pre><code class="language-julia hljs">rand_vec = dist(W,dt,rng)</code></pre><p>otherwise. The signature for <code>bridge</code> is</p><pre><code class="language-julia hljs">bridge!(rand_vec,W,W0,Wh,q,h,rng)</code></pre><p>and the out of place syntax is</p><pre><code class="language-julia hljs">rand_vec = bridge!(W,W0,Wh,q,h,rng)</code></pre><p>Here, <code>W</code> is the noise process, <code>W0</code> is the left side of the current interval, <code>Wh</code> is the right side of the current interval, <code>h</code> is the interval length, and <code>q</code> is the proportion from the left where the interpolation is occuring.</p><p><strong>Direct Construction Example</strong></p><p>The easiest way to show how to directly construct a <code>NoiseProcess</code> is by example. Here we will show how to directly construct a <code>NoiseProcess</code> which generates Gaussian white noise.</p><p>This is the noise process which uses <code>randn!</code>. A special dispatch is added for complex numbers for <code>(randn()+im*randn())/sqrt(2)</code>. This function is <code>DiffEqNoiseProcess.wiener_randn</code> (or with <code>!</code> respectively).</p><p>The first function that must be defined is the noise distribution. This is how to generate <span>$W(t+dt)$</span> given that we know <span>$W(x)$</span> for <span>$x∈[t₀,t]$</span>. For Gaussian white noise, we know that</p><p class="math-container">\[W(dt) ∼ N(0,dt)\]</p><p>for <span>$W(0)=0$</span> which defines the stepping distribution. Thus its noise distribution function is:</p><pre><code class="language-julia hljs">@inline function WHITE_NOISE_DIST(W,dt,rng)
  if typeof(W.dW) &lt;: AbstractArray &amp;&amp; !(typeof(W.dW) &lt;: SArray)
    return @fastmath sqrt(abs(dt))*wiener_randn(rng,W.dW)
  else
    return @fastmath sqrt(abs(dt))*wiener_randn(rng,typeof(W.dW))
  end
end</code></pre><p>for the out of place versions, and for the inplace versions</p><pre><code class="language-julia hljs">function INPLACE_WHITE_NOISE_DIST(rand_vec,W,dt,rng)
  wiener_randn!(rng,rand_vec)
  sqrtabsdt = @fastmath sqrt(abs(dt))
  @. rand_vec *= sqrtabsdt
end</code></pre><p>Optionally, we can provide a bridging distribution. This is the distribution of <span>$W(qh)$</span> for <span>$q∈[0,1]$</span> given that we know <span>$W(0)=0$</span> and <span>$W(h)=Wₕ$</span>. For Brownian motion, this is known as the Brownian Bridge, and is well known to have the distribution:</p><p class="math-container">\[W(qh) ∼ N(qWₕ,(1-q)qh)\]</p><p>Thus we have the out-of-place and in-place versions as:</p><pre><code class="language-julia hljs">function WHITE_NOISE_BRIDGE(W,W0,Wh,q,h,rng)
  if typeof(W.dW) &lt;: AbstractArray
    return @fastmath sqrt((1-q)*q*abs(h))*wiener_randn(rng,W.dW)+q*Wh
  else
    return @fastmath sqrt((1-q)*q*abs(h))*wiener_randn(rng,typeof(W.dW))+q*Wh
  end
end
function INPLACE_WHITE_NOISE_BRIDGE(rand_vec,W,W0,Wh,q,h,rng)
  wiener_randn!(rng,rand_vec)
  #rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*Wh
  sqrtcoeff = @fastmath sqrt((1-q)*q*abs(h))
  @. rand_vec = sqrtcoeff*rand_vec+q*Wh
end</code></pre><p>These functions are then placed in a noise process:</p><pre><code class="language-julia hljs">NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE;kwargs)
NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE;kwargs)</code></pre><p>Notice that we can optionally provide an alternative adaptive algorithm for the timestepping rejections. <code>RSWM()</code> defaults to the Rejection Sampling with Memory 3 algorithm (RSwM3).</p><p>Note that the standard constructors are simply:</p><pre><code class="language-julia hljs">WienerProcess(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE;kwargs)
WienerProcess!(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE;kwargs)</code></pre><p>These will generate a Wiener process, which can be stepped with <code>step!(W,dt)</code>, and interpolated as <code>W(t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L3-L145">source</a></section></article><h2 id="Alternative-AbstractNoiseProcess-Types"><a class="docs-heading-anchor" href="#Alternative-AbstractNoiseProcess-Types">Alternative <code>AbstractNoiseProcess</code> Types</a><a id="Alternative-AbstractNoiseProcess-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-AbstractNoiseProcess-Types" title="Permalink"></a></h2><p>In addition to the mathematically-defined noise processes above, there exists more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations.</p><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseWrapper" href="#DiffEqNoiseProcess.NoiseWrapper"><code>DiffEqNoiseProcess.NoiseWrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NoiseWrapper{T,N,Tt,T2,T3,T4,ZType,inplace} &lt;: AbstractNoiseProcess{T,N,Vector{T2},inplace}</code></pre><p>This produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to re-use a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NoiseWrapper(source::AbstractNoiseProcess{T,N,Vector{T2},inplace};
                      reset=true,reverse=false,indx=nothing) where {T,N,T2,inplace}</code></pre><p><strong>NoiseWrapper Example</strong></p><p>In this example, we will solve an SDE three times:</p><ul><li>First to generate a noise process</li><li>Second with the same timesteps to show the values are the same</li><li>Third with half-sized timsteps</li></ul><p>First we will generate a noise process by solving an SDE:</p><pre><code class="language-julia hljs">using StochasticDiffEq,  DiffEqNoiseProcess
f1(u, p, t) = 1.01u
g1(u, p, t) = 1.01u
dt = 1//2^(4)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0))
sol1 = solve(prob1,EM(),dt=dt,save_noise = true)</code></pre><p>Now we wrap the noise into a NoiseWrapper and solve the same problem:</p><pre><code class="language-julia hljs">W2 = NoiseWrapper(sol1.W)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W2)
sol2 = solve(prob1,EM(),dt=dt)</code></pre><p>We can test</p><pre><code class="language-julia hljs">@test sol1.u ≈ sol2.u</code></pre><p>to see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller <code>dt</code>:</p><pre><code class="language-julia hljs">W3 = NoiseWrapper(sol1.W)
prob2 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W3)

dt = 1//2^(5)
sol3 = solve(prob2,EM(),dt=dt)</code></pre><p>We can plot the results to see what this looks like:</p><pre><code class="language-julia hljs">using Plots
plot(sol1)
plot!(sol2)
plot!(sol3)</code></pre><p><img src="../assets/noise_process.png" alt="noise_process"/></p><p>In this plot, <code>sol2</code> covers up <code>sol1</code> because they hit essentially the same values. You can see that <code>sol3</code> its similar to the others, because it&#39;s using the same underlying noise process just sampled much finer.</p><p>To double check, we see that:</p><pre><code class="language-julia hljs">plot(sol1.W)
plot!(sol2.W)
plot!(sol3.W)</code></pre><p><img src="../assets/coupled_wiener.png" alt="coupled_wiener"/></p><p>the coupled Wiener processes coincide at every other time point, and the intermediate timepoints were calculated according to a Brownian bridge.</p><p><strong>Adaptive NoiseWrapper Example</strong></p><p>Here we will show that the same noise can be used with the adaptive methods using the <code>NoiseWrapper</code>. <code>SRI</code> and <code>SRIW1</code> use slightly different error estimators, and thus give slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:</p><pre><code class="language-julia hljs">prob = SDEProblem(f1,g1,ones(2),(0.0,1.0))
sol4 = solve(prob,SRI(),abstol=1e-8, save_noise = true)

W2 = NoiseWrapper(sol4.W)
prob2 = SDEProblem(f1,g1,ones(2),(0.0,1.0),noise=W2)
sol5 = solve(prob2,SRIW1(),abstol=1e-8)

using Plots
plot(sol4)
plot!(sol5)</code></pre><p><img src="../assets/SRI_SRIW1_diff.png" alt="SRI_SRIW1_diff"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L327-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseFunction" href="#DiffEqNoiseProcess.NoiseFunction"><code>DiffEqNoiseProcess.NoiseFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NoiseFunction{T,N,wType,zType,Tt,T2,T3,inplace} &lt;: AbstractNoiseProcess{T,N,nothing,inplace}</code></pre><p>This allows you to use any arbitrary function <code>W(t)</code> as a <code>NoiseProcess</code>. This will use the function lazily, only caching values required to minimize function calls, but not store the entire noise array. This requires an initial time point <code>t0</code> in the domain of <code>W</code>. A second function is needed if the desired SDE algorithm requires multiple processes.</p><pre><code class="language-julia hljs">function NoiseFunction{iip}(t0,W,Z=nothing;
                            noise_prototype=W(nothing,nothing,t0),
                            reset=true) where iip</code></pre><p>Additionally, one can use an in-place function <code>W(out1,out2,t)</code> for more efficient generation of the arrays for multi-dimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the <code>noise_prototype</code> needs to be set.</p><p><strong>NoiseFunction Example</strong></p><p>The <code>NoiseFunction</code> is pretty simple: pass a function. As a silly example, we can use <code>exp</code> as a noise process by doing:</p><pre><code class="language-julia hljs">f(t) = exp(t)
W = NoiseFunction(0.0,f)</code></pre><p>If it&#39;s multi-dimensional and an in-place function is used, the <code>noise_prototype</code> must be given. For example:</p><pre><code class="language-julia hljs">f(out,t) = (out.=exp(t))
W = NoiseFunction(0.0,f,noise_prototype=rand(4))</code></pre><p>This allows you to put arbitrarily weird noise into SDEs and RODEs. Have fun.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L493-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseGrid" href="#DiffEqNoiseProcess.NoiseGrid"><code>DiffEqNoiseProcess.NoiseGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A noise grid builds a noise process from arrays of points. For example, you can generate your desired noise process as an array <code>W</code> with timepoints <code>t</code>, and use the constructor:</p><pre><code class="language-julia hljs">NoiseGrid(t,W,Z=nothing;reset=true)</code></pre><p>to build the associated noise process. This process comes with a linear interpolation of the given points, and thus the grid does not have to match the grid of integration. Thus this can be used for adaptive solutions as well. However, one must make note that the fidelity of the noise process is linked to how fine the noise grid is determined: if the noise grid is sparse on points compared to the integration, then its distributional properties may be slightly perturbed by the linear interpolation. Thus its suggested that the grid size at least approximately match the number of time steps in the integration to ensure accuracy.</p><p>For a one-dimensional process, <code>W</code> should be an <code>AbstractVector</code> of <code>Number</code>s. For multi-dimensional processes, <code>W</code> should be an <code>AbstractVector</code> of the <code>noise_prototype</code>.</p><p><strong>NoiseGrid</strong></p><p>In this example, we will show you how to define your own version of Brownian motion using an array of pre-calculated points. In normal usage you should use <code>WienerProcess</code> instead since this will have distributionally-exact interpolations while the noise grid uses linear interpolations, but this is a nice example of the workflow.</p><p>To define a <code>NoiseGrid</code> you need to have a set of time points and a set of values for the process. Let&#39;s define a Brownian motion on <code>(0.0,1.0)</code> with a <code>dt=0.001</code>. To do this,</p><pre><code class="language-julia hljs">dt = 0.001
t = 0:dt:1
brownian_values = cumsum([0;[sqrt(dt)*randn() for i in 1:length(t)-1]])</code></pre><p>Now we build the <code>NoiseGrid</code> using these values:</p><pre><code class="language-julia hljs">W = NoiseGrid(t,brownian_values)</code></pre><p>We can then pass <code>W</code> as the <code>noise</code> argument of an <code>SDEProblem</code> to use it in an SDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L598-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseApproximation" href="#DiffEqNoiseProcess.NoiseApproximation"><code>DiffEqNoiseProcess.NoiseApproximation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>In many cases, one would like to define a noise process directly by a stochastic differential equation which does not have an analytical solution. Of course, this will not be distributionally-exact and how well the properties match depends on how well the differential equation is integrated, but in many cases this can be used as a good approximation when other methods are much more difficult.</p><p>A <code>NoiseApproximation</code> is defined by a <code>DEIntegrator</code>. The constructor for a <code>NoiseApproximation</code> is:</p><pre><code class="language-julia hljs">NoiseApproximation(source1::DEIntegrator,source2::Union{DEIntegrator,Nothing}=nothing;reset=true)</code></pre><p>The <code>DEIntegrator</code> should have a final time point of integration far enough such that it will not halt during the integration. For ease of use, you can use a final time point as <code>Inf</code>. Note that the time points do not have to match the time points of the future integration since the interpolant of the SDE solution will be used. Thus the limiting factor is error tolerance and not hitting specific points.</p><p><strong>NoiseApproximation Example</strong></p><p>In this example we will show how to use the <code>NoiseApproximation</code> in order to build our own Geometric Brownian Motion from its stochastic differential equation definition. In normal usage, you should use the <code>GeometricBrownianMotionProcess</code> instead since that is more efficient and distributionally-exact.</p><p>First, let&#39;s define the <code>SDEProblem</code>. Here will use a timespan <code>(0.0,Inf)</code> so that way the noise can be used over an indefinite integral.</p><pre><code class="language-julia hljs">const μ = 1.5
const σ = 1.2
f(u, p, t) = μ*u
g(u, p, t) = σ*u
prob = SDEProblem(f,g,1.0,(0.0,Inf))</code></pre><p>Now we build the noise process by building the integrator and sending that integrator to the <code>NoiseApproximation</code> constructor:</p><pre><code class="language-julia hljs">integrator = init(prob,SRIW1())
W = NoiseApproximation(integrator)</code></pre><p>We can use this noise process like any other noise process. For example, we can now build a geometric Brownian motion whose noise process is colored noise that itself is a geometric Brownian motion:</p><pre><code class="language-julia hljs">prob = SDEProblem(f,g,1.0,(0.0,Inf),noise=W)</code></pre><p>The possibilities are endless.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L696-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.VirtualBrownianTree" href="#DiffEqNoiseProcess.VirtualBrownianTree"><code>DiffEqNoiseProcess.VirtualBrownianTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>VirtualBrownianTree</code> builds the noise process starting from an initial time <code>t0</code>, the first value of the proces <code>W0</code>, and (optionally) the first value <code>Z0</code> for an auxiliary pseudo-process. The constructor is given as</p><pre><code class="language-julia hljs">VirtualBrownianTree(t0,W0,Z0=nothing,dist=WHITE_NOISE_DIST,bridge=VBT_BRIDGE;kwargs...)</code></pre><p>where <code>dist</code> specifies the distribution that is used to generate the end point(s) <code>Wend</code> (<code>Zend</code>) of the noise process for the final time <code>tend</code>. <code>bridge</code> denotes the distribution of the employed Brownian bridge.  Per default <code>tend</code> is fixed to <code>t0+1</code> but can be changed by passing a custom <code>tend</code> as a keyword argument. The following keyword arguments are available:</p><ul><li><code>tend</code> is the end time of the noise process.</li><li><code>Wend</code> is the end value of the noise process.</li><li><code>Zend</code> is the end value of the pseudo-noise process.</li><li><code>atol</code> represents the absolute tolerance determining when the recursion is  terminated.</li><li><code>tree_depth</code> allows one to store a cache of seeds, noise values, and times  to speed up the simulation by reducing the recursion steps.</li><li><code>search_depth</code> maximal search depth for the tree if <code>atol</code> is not reached.</li><li><code>rng</code> the splittable PRNG used for generating the random numbers.  Default: <code>Threefry4x()</code> from the Random123 package.</li></ul><p><strong>VirtualBrownianTree Example</strong></p><p>In this example, we define a multi-dimensional Brownian process based on a <code>VirtualBrownianTree</code> with a minimal <code>tree_depth=0</code> such that memory consumption is minimized.</p><pre><code class="language-julia hljs">  W0 = zeros(10)
  W = VirtualBrownianTree(0.0,W0; tree_depth=0)

  prob = NoiseProblem(W,(0.0,1.0))
  sol = solve(prob;dt=1/10)</code></pre><p>Using a look-up cache by increasing <code>tree_depth</code> can significantly reduce the runtime. Thus, the <code>VirtualBrownianTree</code> allows for trading off speed for memory in a simple manner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L804-L847">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.SimpleNoiseProcess" href="#DiffEqNoiseProcess.SimpleNoiseProcess"><code>DiffEqNoiseProcess.SimpleNoiseProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SimpleNoiseProcess{T,N,Tt,T2,T3,ZType,F,F2,inplace,RNGType} &lt;: AbstractNoiseProcess{T,N,Vector{T2},inplace}</code></pre><p>Like <code>NoiseProcess</code> but without support for adaptivity. This makes it lightweight and slightly faster.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>SimpleNoiseProcess</code> should not be used with adaptive SDE solvers as it will lead to incorrect results.</p></div></div><pre><code class="language-julia hljs">function SimpleNoiseProcess{iip}(t0,W0,Z0,dist,bridge;
                                 save_everystep=true,
                                 rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
                                 reset = true, reseed = true) where iip</code></pre><ul><li><code>t0</code> is the first timepoint</li><li><code>W0</code> is the first value of the process.</li><li><code>Z0</code> is the first value of the pseudo-process. This is necessary for higher order algorithms. If it&#39;s not needed, set to <code>nothing</code>.</li><li><code>dist</code> the distribution for the steps over time.</li><li><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</li><li><code>save_everystep</code> whether to save every step of the Brownian timeseries.</li><li><code>rng</code> the local RNG used for generating the random numbers.</li><li><code>reset</code> whether to reset the process with each solve.</li><li><code>reseed</code> whether to reseed the process with each solve.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L236-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.BoxWedgeTail" href="#DiffEqNoiseProcess.BoxWedgeTail"><code>DiffEqNoiseProcess.BoxWedgeTail</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BoxWedgeTail{T,N,Tt,TA,T2,T3,ZType,F,F2,inplace,RNGType,tolType,
  spacingType,jpdfType,boxType,wedgeType,tailType,distBWTType,distΠType} &lt;: AbstractNoiseProcess{T,N,Vector{T2},inplace}</code></pre><p>The method for random generation of stochastic area integrals due to Gaines and Lyons. The method is based on Marsaglia&#39;s &quot;rectangle-wedge-tail&quot; approach for two dimensions.</p><p>3 different groupings for the boxes are implemented.</p><ul><li>box_grouping = :Columns (full, i.e., as large as possible, columns on a square spanned by dr and da)</li><li>box_grouping = :none (no grouping)</li><li>box_grouping = :MinEntropy (default, grouping that achieves a smaller entropy than the column wise grouping and thus allows for slightly faster sampling – but has a slightly larger amount of groups)</li></ul><p>The sampling is based on the Distributions.jl package, i.e., to sample from one of the many distributions, a uni-/bi-variate distribution from Distributions.jl is constructed and then rand(..) is used.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">BoxWedgeTail{iip}(t0,W0,Z0,dist,bridge;
                      rtol=1e-8,nr=4,na=4,nz=10,
                      box_grouping = :MinEntropy,
                      sqeezing = true,
                      save_everystep=true,
                      rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
                      reset=true, reseed=true) where iip</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/types.jl#L957-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqNoiseProcess.pCN" href="#DiffEqNoiseProcess.pCN"><code>DiffEqNoiseProcess.pCN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pCN(noise::AbstractNoiseProcess, ρ; reset=true,reverse=false,indx=nothing)</code></pre><p>Create a new, but correlated noise process from <code>noise</code> and additional entropy with correlation ρ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/pCN.jl#L37-L41">source</a></section><section><div><pre><code class="nohighlight hljs">pCN(noise::NoiseGrid, ρ; reset=true, rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)))</code></pre><p>Create a new, but correlated noise process from <code>noise</code> and additional entropy with correlation ρ. This update defines an autoregressive process in the space of Wiener (or noise process) trajectories which can be used as proposal distribution in Metropolis-Hastings algorithms (often called &quot;preconditioned Crank–Nicolson scheme&quot;.)</p><p>External links</p><ul><li><a href="https://en.wikipedia.org/wiki/Preconditioned_Crank–Nicolson_algorithm">Preconditioned Crank–Nicolson algorithm on Wikipedia</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/58bc3ae9c6a364de9da9db0903585a4568c2c2b8/src/pCN.jl#L54-L62">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noise_processes/">« Classic Noise Processes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 20 August 2022 19:44">Saturday 20 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
