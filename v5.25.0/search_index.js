var documenterSearchIndex = {"docs":
[{"location":"abstract_noise_processes/#Abstract-Noise-Processes","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"In addition to the NoiseProcess type, more general AbstractNoiseProcesses are defined. The NoiseGrid allows you to define a noise process from a set of pre-calculated points (the \"normal\" way). The NoiseApproximation allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations.\n\nThe NoiseWrapper allows one to wrap a NoiseProcess from a previous simulation to reuse it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example by solving with a smaller dt) in a distributionally-exact manner. It is demonstrated how the NoiseWrapper can be used to wrap the NoiseProcess of one SDE/RODE solution to reuse the same noise process in another simulation.\n\nThe VirtualBrownianTree allows one to trade speed for O(1) memory usage. Instead of storing Brownian motion increments, the VirtualBrownianTree samples recursively from the midpoint tmid of Brownian bridges, using a splittable PRNG. The recursion terminates when the query time agrees within some tolerance with tmid or when the maximum depth of the tree is reached.\n\nLastly, the NoiseFunction allows you to use any function of time as the noise process, while NoiseTransport lets you define a random process as the transport of a random variable or a random vector by a time-dependent function. Together, these functionalities allow you to define any colored noise process and use it efficiently and accurately in your simulations.","category":"section"},{"location":"abstract_noise_processes/#The-Standard-AbstractNoiseProcess","page":"Abstract Noise Processes","title":"The Standard AbstractNoiseProcess","text":"","category":"section"},{"location":"abstract_noise_processes/#Alternative-AbstractNoiseProcess-Types","page":"Abstract Noise Processes","title":"Alternative AbstractNoiseProcess Types","text":"In addition to the mathematically-defined noise processes above, there exists more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations.","category":"section"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseProcess","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseProcess","text":"NoiseProcess{T, N, Tt, T2, T3, ZType, F, F2, inplace, S1, S2, RSWM, C, RNGType} <:\n{T, N, Vector{T2}, inplace}\n\nA NoiseProcess is a type defined as:\n\nNoiseProcess(t0, W0, Z0, dist, bridge;\n    iip = SciMLBase.isinplace(dist, 3),\n    rswm = RSWM(), save_everystep = true,\n    rng = Random.default_rng(),\n    reset = true, reseed = true)\n\nt0 is the first timepoint\nW0 is the first value of the process.\nZ0 is the first value of the pseudo-process. This is necessary for higher order algorithms. If it's not needed, set to nothing.\ndist the distribution of the steps over time.\nbridge the bridging distribution. Optional, but required for adaptivity and interpolating at new values.\ncovariance is the covariance matrix of the noise process. If not provided, the noise is assumed to be uncorrelated in each variable.\nsave_everystep whether to save every step of the Brownian timeseries.\nrng the local RNG used for generating the random numbers.\nreset whether to reset the process with each solve.\nreseed whether to reseed the process with each solve.\n\nThe signature for the dist is:\n\ndist!(rand_vec, dW, W, dt, u, p, t, rng)\n\nfor inplace functions, and:\n\nrand_vec = dist(dW, W, dt, u, p, t, rng)\n\notherwise. The signature for bridge is:\n\nbridge!(rand_vec, dW, W, W0, Wh, q, h, u, p, t, rng)\n\nand the out of place syntax is:\n\nrand_vec = bridge(dW, W, W0, Wh, q, h, u, p, t, rng)\n\nHere, W is the noise process, W0 is the left side of the current interval, Wh is the right side of the current interval, h is the interval length, and q is the proportion from the left where the interpolation is occurring.\n\nDirect Construction Example\n\nThe easiest way to show how to directly construct a NoiseProcess is by example. Here we will show how to directly construct a NoiseProcess which generates Gaussian white noise.\n\nThis is the noise process, that uses randn!. A special dispatch is added for complex numbers for (randn()+im*randn())/sqrt(2). This function is DiffEqNoiseProcess.wiener_randn (or with ! respectively).\n\nThe first function that must be defined is the noise distribution. This is how to generate W(t+dt) given that we know W(x) for xt₀t. For Gaussian white noise, we know that\n\nW(dt)  N(0dt)\n\nfor W(0)=0 which defines the stepping distribution. Thus, its noise distribution function is:\n\n@inline function WHITE_NOISE_DIST(dW, W, dt, u, p, t, rng)\n    if W.dW isa AbstractArray && !(W.dW isa SArray)\n        return @fastmath sqrt(abs(dt)) * wiener_randn(rng, W.dW)\n    else\n        return @fastmath sqrt(abs(dt)) * wiener_randn(rng, typeof(W.dW))\n    end\nend\n\nfor the out of place versions, and for the inplace versions\n\nfunction INPLACE_WHITE_NOISE_DIST(rand_vec, dW, W, dt, u, p, t, rng)\n    wiener_randn!(rng, rand_vec)\n    sqrtabsdt = @fastmath sqrt(abs(dt))\n    @. rand_vec *= sqrtabsdt\nend\n\nOptionally, we can provide a bridging distribution. This is the distribution of W(qh) for q01 given that we know W(0)=0 and W(h)=Wₕ. For Brownian motion, this is known as the Brownian Bridge, and is well known to have the distribution:\n\nW(qh)  N(qWₕ(1-q)qh)\n\nThus, we have the out-of-place and in-place versions as:\n\nfunction WHITE_NOISE_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)\n    if W.dW isa AbstractArray\n        return @fastmath sqrt((1 - q) * q * abs(h)) * wiener_randn(rng, W.dW) + q * Wh\n    else\n        return @fastmath sqrt((1 - q) * q * abs(h)) * wiener_randn(rng, typeof(W.dW)) +\n                         q * Wh\n    end\nend\nfunction INPLACE_WHITE_NOISE_BRIDGE(rand_vec, dW, W, W0, Wh, q, h, u, p, t, rng)\n    wiener_randn!(rng, rand_vec)\n    #rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*Wh\n    sqrtcoeff = @fastmath sqrt((1 - q) * q * abs(h))\n    @. rand_vec = sqrtcoeff * rand_vec + q * Wh\nend\n\nThese functions are then placed in a noise process:\n\nNoiseProcess(t0, W0, Z0, WHITE_NOISE_DIST, WHITE_NOISE_BRIDGE; kwargs)\nNoiseProcess(t0, W0, Z0, INPLACE_WHITE_NOISE_DIST, INPLACE_WHITE_NOISE_BRIDGE; kwargs)\n\nNotice that we can optionally provide an alternative adaptive algorithm for the timestepping rejections. RSWM() defaults to the Rejection Sampling with Memory 3 algorithm (RSwM3).\n\nNote that the standard constructors are simply:\n\nfunction WienerProcess(t0, W0, Z0 = nothing)\n    NoiseProcess(t0, W0, Z0, WHITE_NOISE_DIST, WHITE_NOISE_BRIDGE; kwargs)\nend\nfunction WienerProcess!(t0, W0, Z0 = nothing)\n    NoiseProcess(t0, W0, Z0, INPLACE_WHITE_NOISE_DIST, INPLACE_WHITE_NOISE_BRIDGE; kwargs)\nend\n\nThese will generate a Wiener process, which can be stepped with step!(W,dt), and interpolated as W(t).\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseWrapper","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseWrapper","text":"NoiseWrapper{T, N, Tt, T2, T3, T4, ZType, inplace} <:\nAbstractNoiseProcess{T, N, Vector{T2}, inplace}\n\nThis produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to reuse a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.\n\nConstructor\n\nNoiseWrapper(source::AbstractNoiseProcess{T, N, Vector{T2}, inplace};\n    reset = true, reverse = false, indx = nothing) where {T, N, T2, inplace}\n\nNoiseWrapper Example\n\nIn this example, we will solve an SDE three times:\n\nFirst, to generate a noise process\nSecond, with the same timesteps to show the values are the same\nThird, with half-sized timesteps\n\nFirst, we will generate a noise process by solving an SDE:\n\nusing StochasticDiffEq, DiffEqNoiseProcess\nf1(u, p, t) = 1.01u\ng1(u, p, t) = 1.01u\ndt = 1 // 2^(4)\nprob1 = SDEProblem(f1, g1, 1.0, (0.0, 1.0))\nsol1 = solve(prob1, EM(), dt = dt, save_noise = true)\n\nNow we wrap the noise into a NoiseWrapper and solve the same problem:\n\nW2 = NoiseWrapper(sol1.W)\nprob1 = SDEProblem(f1, g1, 1.0, (0.0, 1.0), noise = W2)\nsol2 = solve(prob1, EM(), dt = dt)\n\nWe can test\n\n@test sol1.u ≈ sol2.u\n\nto see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller dt:\n\nW3 = NoiseWrapper(sol1.W)\nprob2 = SDEProblem(f1, g1, 1.0, (0.0, 1.0), noise = W3)\n\ndt = 1 // 2^(5)\nsol3 = solve(prob2, EM(), dt = dt)\n\nWe can plot the results to see what this looks like:\n\nusing Plots\nplot(sol1)\nplot!(sol2)\nplot!(sol3)\n\n(Image: noise_process)\n\nIn this plot, sol2 covers up sol1 because they hit essentially the same values. You can see that sol3 is similar to the others, because it's using the same underlying noise process, just sampled much finer.\n\nTo double-check, we see that:\n\nplot(sol1.W)\nplot!(sol2.W)\nplot!(sol3.W)\n\n(Image: coupled_wiener)\n\nthe coupled Wiener processes coincide at every other time point, and the intermediate timepoints were calculated according to a Brownian bridge.\n\nAdaptive NoiseWrapper Example\n\nHere we will show that the same noise can be used with the adaptive methods using the NoiseWrapper. SRI and SRIW1 use slightly different error estimators, and thus have slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:\n\nprob = SDEProblem(f1, g1, ones(2), (0.0, 1.0))\nsol4 = solve(prob, SRI(), abstol = 1e-8, save_noise = true)\n\nW2 = NoiseWrapper(sol4.W)\nprob2 = SDEProblem(f1, g1, ones(2), (0.0, 1.0), noise = W2)\nsol5 = solve(prob2, SRIW1(), abstol = 1e-8)\n\nusing Plots\nplot(sol4)\nplot!(sol5)\n\n(Image: SRI_SRIW1_diff)\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseFunction","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseFunction","text":"NoiseFunction{T, N, wType, zType, Tt, T2, T3, inplace} <:\nAbstractNoiseProcess{T, N, nothing, inplace}\n\nThis allows you to use any arbitrary function W(t) as a NoiseProcess. This will use the function lazily, only caching values required to minimize function calls, but not storing the entire noise array. This requires an initial time point t0 in the domain of W. A second function is needed if the desired SDE algorithm requires multiple processes.\n\nNoiseFunction{iip}(t0, W, Z = nothing;\n    noise_prototype = W(nothing, nothing, t0),\n    reset = true) where {iip}\n\nAdditionally, one can use an in-place function W(out1,out2,t) for more efficient generation of the arrays for mulitidimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the noise_prototype needs to be set.\n\nNoiseFunction Example\n\nThe NoiseFunction is pretty simple: pass a function. As a silly example, we can use exp as a noise process by doing:\n\nf(u, p, t) = exp(t)\nW = NoiseFunction(0.0, f)\n\nIf it's mulitidimensional and an in-place function is used, the noise_prototype must be given. For example:\n\nf(out, u, p, t) = (out .= exp(t))\nW = NoiseFunction(0.0, f, noise_prototype = rand(4))\n\nThis allows you to put arbitrarily weird noise into SDEs and RODEs. Have fun.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseTransport","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseTransport","text":"NoiseTransport{T, N, wType, zType, Tt, T2, T3, TRV, Trv, RNGType, inplace} <:\nAbstractNoiseProcess{T, N, nothing, inplace}\n\nThis allows you to define stochastic processes of the form W(t) = f(u, p, t, RV), where f is a function and RV represents a random variable. This will use the function lazily, only caching values required to minimize function calls, but not storing the entire noise array. This requires an initial time point t0 in the domain of W. A second function is needed if the desired SDE algorithm requires multiple processes.\n\nNoiseTransport{iip}(t0,\n    W,\n    RV,\n    rv,\n    Z = nothing;\n    rng = Random.default_rng(),\n    reset = true,\n    reseed = true,\n    noise_prototype = W(nothing, nothing, t0, rv)) where {iip}\n\nNoiseTransport(t0,\n    W,\n    RV;\n    rng = Random.default_rng(),\n    reset = true,\n    reseed = true,\n    kwargs...)\n\nAdditionally, one can use an in-place function W(out, u, p, t, rv) for more efficient generation of the arrays for mulitidimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the noise_prototype needs to be set.\n\nNoiseTransport Example\n\nThe NoiseTransport requires you to pass an initial time, a transport function, and a random variable. The random variable can be either out-of-place or in-place. It is assumed it is out-of-place when the realization is a subtype of Number, and in-place, when it is a subtype of AbstractArray. Here, a random variable is any function that accepts a random number generator, in the out-of-place case (e.g. rand(rng)), or a random number generator and a realization to be mutated (e.g. rand!(rng, rv)).\n\nAn optional realization rv may be given. The realization rv is used in the first time an AbstractRODEProblem is solved. Subsequent runs of the same problem will draw a different realization from the random variable RV, unless reseed is set to false. In the case of a NoiseProblem, however, a new realization will happen at the first run already, and, in this case, rv can be regarded as a realization prototype, which is necessary in the case of a random vector.\n\nAs a first example, let us implement the Gaussian noise W(t) = sin(Yt), where Y is a normal random variable.\n\nf(u, p, t, rv) = sin(rv * t)\nt0 = 0.0\nW = NoiseTransport(t0, f, randn)\n\nIf we want to build a scalar random process out of a random vector, then an in-place version of the random vector is required, as follows. We can also use parameters in the transport function, in which case the noise_prototype must be given.\n\nusing Random: randn!\nf(u, p, t, rv) = sin(p[1] * t + rv[1]) + cos(p[2] * t + rv[2])\nt0 = 0.0\nrv = randn(2)\np = (π, 2π)\nW = NoiseTransport(t0, f, randn!, rv, noise_prototype = f(nothing, p, t0, rv))\n\nIf the random process is expected to be mulitidimensional, it is preferable to use an in-place transport function, and, in this case, the noise_prototype must be given. Here is an example with a scalar random vector with a beta distribution, from Distributions.jl.\n\nf!(out, u, p, t, rv) = (out .= sin.(rv * t))\nt0 = 0.0\nRV(rng) = rand(rng, Beta(2, 3))\nrv = 0.0\nW = NoiseTransport(t0, f!, RV, rv, noise_prototype = zeros(4))\n\nWe can also have a random vector with a mulitidimensional process, in which case an in-place version of RV is required. For example.\n\nusing Random: randn!\n\nfunction f!(out, u, p, t, v)\n    out[1] = sin(v[1] * t)\n    out[2] = sin(t + v[2])\n    out[3] = cos(t) * v[1] + sin(t) * v[2]\n    nothing\nend\n\nt0 = 0.0\nRV!(rng, v) = (v[1] = randn(rng); v[2] = rand(rng))\nrv = zeros(2)\n\nW = NoiseTransport(t0, f!, RV!, rv, noise_prototype = zeros(3))\n\nA NoiseTransport can be used as driving noise for SDEs and RODEs. Have fun!\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseGrid","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseGrid","text":"A noise grid builds a noise process from arrays of points. For example, you can generate your desired noise process as an array W with timepoints t, and use the constructor:\n\nNoiseGrid(t, W, Z = nothing; reset = true)\n\nto build the associated noise process. This process comes with a linear interpolation of the given points, and thus the grid does not have to match the grid of integration. Thus, this can be used for adaptive solutions as well. However, one must take note that the fidelity of the noise process is linked to how fine the noise grid is determined: if the noise grid is sparse on points compared to the integration, then its distributional properties may be slightly perturbed by the linear interpolation. Thus, it's suggested that the grid size at least approximates the number of time steps in the integration to ensure accuracy.\n\nFor a one-dimensional process, W should be an AbstractVector of Numbers. For mulitidimensional processes, W should be an AbstractVector of the noise_prototype.\n\nNoiseGrid\n\nIn this example, we will show you how to define your own version of Brownian motion using an array of pre-calculated points. In normal usage, you should use WienerProcess instead, since this will have distributionally-exact interpolations while the noise grid uses linear interpolations, but this is a nice example of the workflow.\n\nTo define a NoiseGrid you need to have a set of time points and a set of values for the process. Let's define a Brownian motion on (0.0,1.0) with a dt=0.001. To do this,\n\ndt = 0.001\nt = 0:dt:1\nbrownian_values = cumsum([0; [sqrt(dt) * randn() for i in 1:(length(t) - 1)]])\n\nNow we build the NoiseGrid using these values:\n\nW = NoiseGrid(t, brownian_values)\n\nWe can then pass W as the noise argument of an SDEProblem to use it in an SDE.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseApproximation","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseApproximation","text":"In many cases, one would like to define a noise process directly by a stochastic differential equation which does not have an analytical solution. Of course, this will not be distributionally-exact and how well the properties match depends on how well the differential equation is integrated, but in many cases , this can be used as a good approximation when other methods are much more difficult.\n\nA NoiseApproximation is defined by a DEIntegrator. The constructor for a NoiseApproximation is:\n\nNoiseApproximation(source1::DEIntegrator,\n    source2::Union{DEIntegrator, Nothing} = nothing;\n    reset = true)\n\nThe DEIntegrator should have a final time point of integration far enough away, such that it will not halt during the integration. For ease of use, you can use a final time point as Inf. Note that the time points do not have to match the time points of the future integration, since the interpolant of the SDE solution will be used. Thus, the limiting factor is error tolerance, and not hitting specific points.\n\nNoiseApproximation Example\n\nIn this example, we will show how to use the NoiseApproximation to build our own Geometric Brownian Motion from its stochastic differential equation definition. In normal usage, you should use the GeometricBrownianMotionProcess instead since that is more efficient and distributionally-exact.\n\nFirst, let's define the SDEProblem. Here, we use a timespan (0.0,Inf) so that the noise can be used over an indefinite integral.\n\nconst μ = 1.5\nconst σ = 1.2\nf(u, p, t) = μ * u\ng(u, p, t) = σ * u\nprob = SDEProblem(f, g, 1.0, (0.0, Inf))\n\nNow we build the noise process by building the integrator and sending that integrator to the NoiseApproximation constructor:\n\nintegrator = init(prob, SRIW1())\nW = NoiseApproximation(integrator)\n\nWe can use this noise process like any other noise process. For example, we can now build a geometric Brownian motion whose noise process is colored noise that itself is a geometric Brownian motion:\n\nprob = SDEProblem(f, g, 1.0, (0.0, Inf), noise = W)\n\nThe possibilities are endless.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.VirtualBrownianTree","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.VirtualBrownianTree","text":"A VirtualBrownianTree builds the noise process starting from an initial time t0, the first value of the process W0, and (optionally) the first value Z0 for an auxiliary pseudo-process. The constructor is given as\n\nVirtualBrownianTree(t0,\n    W0,\n    Z0 = nothing,\n    dist = WHITE_NOISE_DIST,\n    bridge = VBT_BRIDGE;\n    kwargs...)\n\nwhere dist specifies the distribution that is used to generate the end point(s) Wend (Zend) of the noise process for the final time tend. bridge denotes the distribution of the employed Brownian bridge.  Per default tend is fixed to t0+1 but can be changed by passing a custom tend as a keyword argument. The following keyword arguments are available:\n\ntend is the end time of the noise process.\nWend is the end value of the noise process.\nZend is the end value of the pseudo-noise process.\natol represents the absolute tolerance determining when the recursion is terminated.\ntree_depth allows one to store a cache of seeds, noise values, and times to speed up the simulation by reducing the recursion steps.\nsearch_depth maximal search depth for the tree if atol is not reached.\nrng the splittable PRNG used for generating the random numbers. Default: Threefry4x() from the Random123 package.\n\nVirtualBrownianTree Example\n\nIn this example, we define a mulitidimensional Brownian process based on a VirtualBrownianTree with a minimal tree_depth=0 such that memory consumption is minimized.\n\nW0 = zeros(10)\nW = VirtualBrownianTree(0.0, W0; tree_depth = 0)\n\nprob = NoiseProblem(W, (0.0, 1.0))\nsol = solve(prob; dt = 1 / 10)\n\nUsing a look-up cache by increasing tree_depth can significantly reduce the runtime. Thus, the VirtualBrownianTree allows for trading off speed for memory in a simple manner.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.SimpleNoiseProcess","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.SimpleNoiseProcess","text":"SimpleNoiseProcess{T, N, Tt, T2, T3, ZType, F, F2, inplace, RNGType} <:\nAbstractNoiseProcess{T, N, Vector{T2}, inplace}\n\nLike NoiseProcess but without support for adaptivity. This makes it lightweight and slightly faster.\n\nwarn: Warn\nSimpleNoiseProcess should not be used with adaptive SDE solvers as it will lead to incorrect results.\n\nSimpleNoiseProcess{iip}(t0, W0, Z0, dist, bridge;\n    save_everystep = true,\n    rng = Random.default_rng(),\n    reset = true, reseed = true) where {iip}\n\nt0 is the first timepoint\nW0 is the first value of the process.\nZ0 is the first value of the pseudo-process. This is necessary for higher order algorithms. If it's not needed, set to nothing.\ndist the distribution for the steps over time.\nbridge the bridging distribution. Optional, but required for adaptivity and interpolating at new values.\nsave_everystep whether to save every step of the Brownian timeseries.\nrng the local RNG used for generating the random numbers.\nreset whether to reset the process with each solve.\nreseed whether to reseed the process with each solve.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.BoxWedgeTail","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.BoxWedgeTail","text":"BoxWedgeTail{T, N, Tt, TA, T2, T3, ZType, F, F2, inplace, RNGType, tolType, spacingType,\n    jpdfType, boxType, wedgeType, tailType, distBWTType, distΠType} <:\nAbstractNoiseProcess{T, N, Vector{T2}, inplace}\n\nThe method for random generation of stochastic area integrals due to Gaines and Lyons. The method is based on Marsaglia's \"rectangle-wedge-tail\" approach for two dimensions.\n\n3 different groupings for the boxes are implemented.\n\nbox_grouping = :Columns (full, i.e., as large as possible, columns on a square spanned by dr and da)\nbox_grouping = :none (no grouping)\nbox_grouping = :MinEntropy (default, grouping that achieves a smaller entropy than the column wise grouping and thus allows for slightly faster sampling – but has a slightly larger number of groups)\n\nThe sampling is based on the Distributions.jl package, i.e., to sample from one of the many distributions, a uni-/bi-variate distribution from Distributions.jl is constructed, and then rand(..) is used.\n\nConstructor\n\nBoxWedgeTail{iip}(t0, W0, Z0, dist, bridge;\n    rtol = 1e-8, nr = 4, na = 4, nz = 10,\n    box_grouping = :MinEntropy,\n    sqeezing = true,\n    save_everystep = true,\n    rng = Random.default_rng(),\n    reset = true, reseed = true) where {iip}\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.pCN","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.pCN","text":"pCN(noise::AbstractNoiseProcess, ρ; reset=true,reverse=false,indx=nothing)\n\nCreate a new, but correlated noise process from noise and additional entropy with correlation ρ.\n\n\n\n\n\npCN(noise::NoiseGrid, ρ; reset=true, rng = Random.default_rng())\n\nCreate a new, but correlated noise process from noise and additional entropy with correlation ρ. This update defines an autoregressive process in the space of Wiener (or noise process) trajectories, which can be used as proposal distribution in Metropolis-Hastings algorithms (often called the \"preconditioned Crank–Nicolson scheme\".)\n\nExternal links\n\nPreconditioned Crank–Nicolson algorithm on Wikipedia\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#Noise-Processes-API","page":"Noise Processes API","title":"Noise Processes API","text":"","category":"section"},{"location":"api/noise_processes/#Wiener-Processes","page":"Noise Processes API","title":"Wiener Processes","text":"","category":"section"},{"location":"api/noise_processes/#Standard-Wiener-Process","page":"Noise Processes API","title":"Standard Wiener Process","text":"","category":"section"},{"location":"api/noise_processes/#Real-Valued-Wiener-Process","page":"Noise Processes API","title":"Real-Valued Wiener Process","text":"","category":"section"},{"location":"api/noise_processes/#Correlated-Wiener-Process","page":"Noise Processes API","title":"Correlated Wiener Process","text":"","category":"section"},{"location":"api/noise_processes/#Geometric-Brownian-Motion","page":"Noise Processes API","title":"Geometric Brownian Motion","text":"","category":"section"},{"location":"api/noise_processes/#Ornstein-Uhlenbeck-Process","page":"Noise Processes API","title":"Ornstein-Uhlenbeck Process","text":"","category":"section"},{"location":"api/noise_processes/#Jump-Processes","page":"Noise Processes API","title":"Jump Processes","text":"","category":"section"},{"location":"api/noise_processes/#Bridge-Processes","page":"Noise Processes API","title":"Bridge Processes","text":"","category":"section"},{"location":"api/noise_processes/#Advanced-Noise-Types","page":"Noise Processes API","title":"Advanced Noise Types","text":"","category":"section"},{"location":"api/noise_processes/#Noise-Wrapper","page":"Noise Processes API","title":"Noise Wrapper","text":"","category":"section"},{"location":"api/noise_processes/#Noise-Functions","page":"Noise Processes API","title":"Noise Functions","text":"","category":"section"},{"location":"api/noise_processes/#Noise-from-Data","page":"Noise Processes API","title":"Noise from Data","text":"","category":"section"},{"location":"api/noise_processes/#Noise-Approximation","page":"Noise Processes API","title":"Noise Approximation","text":"","category":"section"},{"location":"api/noise_processes/#Memory-Efficient-Alternatives","page":"Noise Processes API","title":"Memory-Efficient Alternatives","text":"","category":"section"},{"location":"api/noise_processes/#Preconditioned-Crank-Nicolson","page":"Noise Processes API","title":"Preconditioned Crank-Nicolson","text":"","category":"section"},{"location":"api/noise_processes/#DiffEqNoiseProcess.WienerProcess","page":"Noise Processes API","title":"DiffEqNoiseProcess.WienerProcess","text":"The WienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nWienerProcess(t0,W0,Z0=nothing;kwargs...)\nWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.WienerProcess!","page":"Noise Processes API","title":"DiffEqNoiseProcess.WienerProcess!","text":"The WienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nWienerProcess(t0,W0,Z0=nothing;kwargs...)\nWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.SimpleWienerProcess","page":"Noise Processes API","title":"DiffEqNoiseProcess.SimpleWienerProcess","text":"The SimpleWienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\n\nUnlike WienerProcess, this uses the SimpleNoiseProcess and thus does not support adaptivity, but is slightly more lightweight.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.SimpleWienerProcess!","page":"Noise Processes API","title":"DiffEqNoiseProcess.SimpleWienerProcess!","text":"The SimpleWienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\n\nUnlike WienerProcess, this uses the SimpleNoiseProcess and thus does not support adaptivity, but is slightly more lightweight.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.RealWienerProcess","page":"Noise Processes API","title":"DiffEqNoiseProcess.RealWienerProcess","text":"The RealWienerProcess is a Brownian motion that is forced to be real-valued. While the normal WienerProcess becomes complex valued if W0 is complex, this version is real valued for when you want to, for example, solve an SDE defined by complex numbers where the noise is in the reals.\n\nRealWienerProcess(t0,W0,Z0=nothing;kwargs...)\nRealWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.RealWienerProcess!","page":"Noise Processes API","title":"DiffEqNoiseProcess.RealWienerProcess!","text":"The RealWienerProcess is a Brownian motion that is forced to be real-valued. While the normal WienerProcess becomes complex valued if W0 is complex, this version is real valued for when you want to, for example, solve an SDE defined by complex numbers where the noise is in the reals.\n\nRealWienerProcess(t0,W0,Z0=nothing;kwargs...)\nRealWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.CorrelatedWienerProcess","page":"Noise Processes API","title":"DiffEqNoiseProcess.CorrelatedWienerProcess","text":"One can define a CorrelatedWienerProcess which is a Wiener process with correlations between the Wiener processes. The constructor is:\n\nCorrelatedWienerProcess(Γ,t0,W0,Z0=nothing;kwargs...)\nCorrelatedWienerProcess!(Γ,t0,W0,Z0=nothing;kwargs...)\n\nwhere Γ is the constant covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.CorrelatedWienerProcess!","page":"Noise Processes API","title":"DiffEqNoiseProcess.CorrelatedWienerProcess!","text":"One can define a CorrelatedWienerProcess which is a Wiener process with correlations between the Wiener processes. The constructor is:\n\nCorrelatedWienerProcess(Γ,t0,W0,Z0=nothing;kwargs...)\nCorrelatedWienerProcess!(Γ,t0,W0,Z0=nothing;kwargs...)\n\nwhere Γ is the constant covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.GeometricBrownianMotionProcess","page":"Noise Processes API","title":"DiffEqNoiseProcess.GeometricBrownianMotionProcess","text":"A GeometricBrownianMotion process is a Wiener process with constant drift μ and constant diffusion σ. I.e. this is the solution of the stochastic differential equation\n\ndX_t = mu X_t dt + sigma X_t dW_t\n\nThe GeometricBrownianMotionProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:\n\nGeometricBrownianMotionProcess(μ,σ,t0,W0,Z0=nothing;kwargs...)\nGeometricBrownianMotionProcess!(μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.GeometricBrownianMotionProcess!","page":"Noise Processes API","title":"DiffEqNoiseProcess.GeometricBrownianMotionProcess!","text":"A GeometricBrownianMotion process is a Wiener process with constant drift μ and constant diffusion σ. I.e. this is the solution of the stochastic differential equation\n\ndX_t = mu X_t dt + sigma X_t dW_t\n\nThe GeometricBrownianMotionProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:\n\nGeometricBrownianMotionProcess(μ,σ,t0,W0,Z0=nothing;kwargs...)\nGeometricBrownianMotionProcess!(μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.OrnsteinUhlenbeckProcess","page":"Noise Processes API","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckProcess","text":"a Ornstein-Uhlenbeck process, which is a Wiener process defined by the stochastic differential equation\n\ndX_t = theta (mu - X_t) dt + sigma dW_t\n\nThe OrnsteinUhlenbeckProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). The constructor is:\n\nOrnsteinUhlenbeckProcess(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\nOrnsteinUhlenbeckProcess!(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.OrnsteinUhlenbeckProcess!","page":"Noise Processes API","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckProcess!","text":"A Ornstein-Uhlenbeck process, which is a Wiener process defined by the stochastic differential equation\n\ndX_t = theta (mu - X_t) dt + sigma dW_t\n\nThe OrnsteinUhlenbeckProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). The constructor is:\n\nOrnsteinUhlenbeckProcess(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\nOrnsteinUhlenbeckProcess!(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.BrownianBridge","page":"Noise Processes API","title":"DiffEqNoiseProcess.BrownianBridge","text":"A BrownianBridge process is a Wiener process with a pre-defined start and end value. This process is distribution exact and back be back interpolated exactly as well. The constructor is:\n\nBrownianBridge(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\nBrownianBridge!(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\n\nwhere W(t0)=W₀, W(tend)=Wend, and likewise for the Z process if defined.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.BrownianBridge!","page":"Noise Processes API","title":"DiffEqNoiseProcess.BrownianBridge!","text":"A BrownianBridge process is a Wiener process with a pre-defined start and end value. This process is distribution exact and back be back interpolated exactly as well. The constructor is:\n\nBrownianBridge(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\nBrownianBridge!(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\n\nwhere W(t0)=W₀, W(tend)=Wend, and likewise for the Z process if defined.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.GeometricBrownianBridge","page":"Noise Processes API","title":"DiffEqNoiseProcess.GeometricBrownianBridge","text":"A GeometricBrownianBridge is a geometric Brownian motion process with pre-defined start and end values.\n\nThis creates a GBM process that is conditioned to pass through specific values at the beginning and end of the time interval, useful for financial modeling where asset prices must match observed values.\n\nArguments\n\nμ: Drift parameter\nσ: Volatility parameter\nt0: Starting time\ntend: Ending time\nW0: Starting value W(t0)\nWend: Ending value W(tend)\nZ0, Zend: Optional auxiliary process values\n\nExamples\n\n# Stock price bridge from $100 to $110 over 1 year\nbridge = GeometricBrownianBridge(0.05, 0.2, 0.0, 1.0, 100.0, 110.0)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.GeometricBrownianBridge!","page":"Noise Processes API","title":"DiffEqNoiseProcess.GeometricBrownianBridge!","text":"In-place version of GeometricBrownianBridge.\n\nSee GeometricBrownianBridge for details.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.OrnsteinUhlenbeckBridge","page":"Noise Processes API","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckBridge","text":"An OrnsteinUhlenbeckBridge is an Ornstein-Uhlenbeck process with pre-defined start and end values.\n\nThis creates a mean-reverting process that is conditioned to pass through specific values at the beginning and end of the time interval.\n\nArguments\n\nΘ: Mean reversion rate\nμ: Long-term mean\nσ: Volatility parameter\nt0: Starting time\ntend: Ending time\nW0: Starting value W(t0)\nWend: Ending value W(tend)\nZ0: Optional auxiliary process value\n\nExamples\n\n# Mean-reverting process from 1.0 to 0.5 over unit time\nbridge = OrnsteinUhlenbeckBridge(2.0, 0.0, 0.3, 0.0, 1.0, 1.0, 0.5)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.OrnsteinUhlenbeckBridge!","page":"Noise Processes API","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckBridge!","text":"In-place version of OrnsteinUhlenbeckBridge.\n\nSee OrnsteinUhlenbeckBridge for details.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.CompoundPoissonBridge","page":"Noise Processes API","title":"DiffEqNoiseProcess.CompoundPoissonBridge","text":"A CompoundPoissonBridge is a compound Poisson process with pre-defined start and end values.\n\nThis creates a jump process that is conditioned to have specific values at the beginning and end of the time interval. The jumps are distributed to satisfy the endpoint constraint.\n\nArguments\n\nrate: Jump rate (λ parameter)\nt0: Starting time\ntend: Ending time\nW0: Starting value W(t0)\nWend: Ending value W(tend)\n\nExamples\n\n# Jump process from 0 to 5 over unit time with rate 2.0\nbridge = CompoundPoissonBridge(2.0, 0.0, 1.0, 0.0, 5.0)\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.CompoundPoissonBridge!","page":"Noise Processes API","title":"DiffEqNoiseProcess.CompoundPoissonBridge!","text":"In-place version of CompoundPoissonBridge.\n\nSee CompoundPoissonBridge for details.\n\n\n\n\n\n","category":"function"},{"location":"api/noise_processes/#DiffEqNoiseProcess.pCN!","page":"Noise Processes API","title":"DiffEqNoiseProcess.pCN!","text":"pCN!(noise::AbstractNoiseProcess, ρ; reset=true,reverse=false,indx=nothing)\n\nCreate a new, but correlated noise process from noise and additional entropy with correlation ρ. This update defines an autoregressive process in the space of Wiener (or noise process) trajectories, which can be used as proposal distribution in Metropolis-Hastings algorithms (often called the \"preconditioned Crank–Nicolson scheme\".)\n\nExternal links\n\nPreconditioned Crank–Nicolson algorithm on Wikipedia\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#Noise-Process-Interface","page":"Noise Process Interface","title":"Noise Process Interface","text":"This page documents the interface functions for working with noise processes.","category":"section"},{"location":"api/interface/#Step-Management","page":"Noise Process Interface","title":"Step Management","text":"","category":"section"},{"location":"api/interface/#Noise-Process-Types","page":"Noise Process Interface","title":"Noise Process Types","text":"","category":"section"},{"location":"api/interface/#Abstract-Types","page":"Noise Process Interface","title":"Abstract Types","text":"","category":"section"},{"location":"api/interface/#Core-Types","page":"Noise Process Interface","title":"Core Types","text":"","category":"section"},{"location":"api/interface/#Configuration","page":"Noise Process Interface","title":"Configuration","text":"","category":"section"},{"location":"api/interface/#Rejection-Sampling-with-Memory-(RSWM)","page":"Noise Process Interface","title":"Rejection Sampling with Memory (RSWM)","text":"","category":"section"},{"location":"api/interface/#Internal-Functions","page":"Noise Process Interface","title":"Internal Functions","text":"These functions are used internally by the noise process implementations:","category":"section"},{"location":"api/interface/#Distribution-Functions","page":"Noise Process Interface","title":"Distribution Functions","text":"","category":"section"},{"location":"api/interface/#Random-Number-Generation","page":"Noise Process Interface","title":"Random Number Generation","text":"","category":"section"},{"location":"api/interface/#Ornstein-Uhlenbeck-Specific","page":"Noise Process Interface","title":"Ornstein-Uhlenbeck Specific","text":"","category":"section"},{"location":"api/interface/#Geometric-Brownian-Motion-Specific","page":"Noise Process Interface","title":"Geometric Brownian Motion Specific","text":"","category":"section"},{"location":"api/interface/#Compound-Poisson-Specific","page":"Noise Process Interface","title":"Compound Poisson Specific","text":"","category":"section"},{"location":"api/interface/#DiffEqNoiseProcess.accept_step!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.accept_step!","text":"accept_step!(W::NoiseProcess, dt, u, p, setup_next = true)\n\nAccept a noise step, updating the current time and noise values. This function is called by the SDE solvers after a successful integration step.\n\nArguments\n\nW: The noise process\ndt: Time step size (may differ from W.dt due to adaptivity)\nu: Current solution value (for state-dependent noise)\np: Parameters (for state-dependent noise)\nsetup_next: Whether to prepare for the next step\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.reject_step!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.reject_step!","text":"reject_step!(W::NoiseProcess, dtnew, u, p)\n\nHandle rejection of a time step in adaptive algorithms.\n\nWhen an adaptive SDE solver rejects a step, this function uses bridge interpolation to generate appropriate noise values for the smaller time step, maintaining distributional correctness.\n\nArguments\n\nW: The noise process\ndtnew: New (smaller) time step after rejection\nu: Current solution value (for state-dependent noise)\np: Parameters (for state-dependent noise)\n\nDetails\n\nThe function stores unused portions of noise in the RSWM stacks for later use, ensuring the noise process remains distributionally exact despite adaptivity.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.calculate_step!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.calculate_step!","text":"calculate_step!(W::NoiseProcess, dt, u, p)\n\nCalculate noise increments for the given time step.\n\nThis function generates new random values for the noise process according to its distribution function.\n\nArguments\n\nW: The noise process\ndt: Time step size\nu: Current solution value (for state-dependent noise)\np: Parameters (for state-dependent noise)\n\nEffects\n\nUpdates W.dW (and W.dZ if auxiliary process exists) with new noise increments\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.setup_next_step!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.setup_next_step!","text":"setup_next_step!(W::NoiseProcess, u, p)\n\nPrepare the noise process for the next integration step.\n\nThis function manages the Rejection Sampling with Memory (RSWM) algorithm, handling the stacks of pre-computed noise values for adaptive time stepping.\n\nArguments\n\nW: The noise process\nu: Current solution value (for state-dependent noise)\np: Parameters (for state-dependent noise)\n\nDetails\n\nThe function implements different variants of the RSWM algorithm:\n\nRSwM1: Basic rejection sampling\nRSwM2: Improved version with better memory management\nRSwM3: Most advanced version with two-stack system\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.save_noise!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.save_noise!","text":"save_noise!(W::NoiseProcess)\n\nSave the current noise value and time to the process history if it hasn't been saved already. This function is called automatically by the stepping algorithms to maintain the noise trajectory.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.RSWM","page":"Noise Process Interface","title":"DiffEqNoiseProcess.RSWM","text":"RSWM(; discard_length = 1e-15, adaptivealg = :RSwM3)\n\nRejection Sampling with Memory (RSWM) algorithm configuration for noise processes.\n\nRSWM ensures distributional exactness when adaptive time stepping is used with noise processes. It maintains memory of rejected values to avoid biasing the noise distribution.\n\nFields\n\ndiscard_length: Threshold for discarding stored values to save memory. Smaller values use more memory but are more accurate.\nadaptivealg: The adaptive algorithm variant to use (:RSwM3 is recommended)\n\nExamples\n\n# Conservative (high accuracy)\nrswm_accurate = RSWM(discard_length = 1e-12)\n\n# Aggressive (lower memory usage)  \nrswm_fast = RSWM(discard_length = 1e-6)\n\n# Use in noise process\nW = WienerProcess(0.0, 0.0, 1.0; rswm = rswm_accurate)\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.adaptive_alg","page":"Noise Process Interface","title":"DiffEqNoiseProcess.adaptive_alg","text":"adaptive_alg(rswm::RSWM)\n\nGet the adaptive algorithm type from an RSWM configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.WHITE_NOISE_DIST","page":"Noise Process Interface","title":"DiffEqNoiseProcess.WHITE_NOISE_DIST","text":"WHITE_NOISE_DIST(dW, W, dt, u, p, t, rng)\n\nGenerate white noise distributed according to N(0, dt) for use in Wiener processes.\n\nArguments\n\ndW: Noise increment container\nW: Current noise value (unused for white noise)\ndt: Time step\nu: Current state (for state-dependent noise)\np: Parameters\nt: Current time\nrng: Random number generator\n\nReturns\n\nRandom values distributed as N(0, dt), scaled by √dt\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.WHITE_NOISE_BRIDGE","page":"Noise Process Interface","title":"DiffEqNoiseProcess.WHITE_NOISE_BRIDGE","text":"WHITE_NOISE_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate white noise for Brownian bridge interpolation between two points.\n\nArguments\n\ndW: Noise increment container\nW: Current noise value\nW0: Starting noise value\nWh: Target noise value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nReturns\n\nInterpolated noise value that maintains correct distribution\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.VBT_BRIDGE","page":"Noise Process Interface","title":"DiffEqNoiseProcess.VBT_BRIDGE","text":"VBT_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate noise for Virtual Brownian Tree (VBT) bridge interpolation.\n\nThe VBT bridge is a memory-efficient method for generating Brownian paths that can be evaluated at arbitrary time points without storing the entire path.\n\nArguments\n\ndW: Noise increment container\nW: Current noise value\nW0: Starting noise value\nWh: Target noise value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nReturns\n\nInterpolated noise value using the VBT bridge formula\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST","page":"Noise Process Interface","title":"DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST","text":"INPLACE_WHITE_NOISE_DIST(rand_vec, W, dt, u, p, t, rng)\n\nGenerate white noise distributed according to N(0, dt) in-place.\n\nThis is the in-place version of WHITENOISEDIST, modifying the provided array rather than allocating a new one.\n\nArguments\n\nrand_vec: Array to fill with noise values\nW: Current noise value (unused for white noise)\ndt: Time step\nu: Current state (for state-dependent noise)\np: Parameters\nt: Current time\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain random values distributed as N(0, dt)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE","page":"Noise Process Interface","title":"DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE","text":"INPLACE_WHITE_NOISE_BRIDGE(rand_vec, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate white noise for Brownian bridge interpolation in-place.\n\nThis is the in-place version of WHITENOISEBRIDGE, modifying the provided array rather than allocating a new one.\n\nArguments\n\nrand_vec: Array to fill with interpolated noise values\nW: Current noise value\nW0: Starting noise value\nWh: Target noise value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain interpolated noise values\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.INPLACE_VBT_BRIDGE","page":"Noise Process Interface","title":"DiffEqNoiseProcess.INPLACE_VBT_BRIDGE","text":"INPLACE_VBT_BRIDGE(rand_vec, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate noise for Virtual Brownian Tree (VBT) bridge interpolation in-place.\n\nThis is the in-place version of VBT_BRIDGE, modifying the provided array rather than allocating a new one.\n\nArguments\n\nrand_vec: Array to fill with interpolated noise values\nW: Current noise value\nW0: Starting noise value\nWh: Target noise value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain VBT-interpolated noise values\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.REAL_WHITE_NOISE_DIST","page":"Noise Process Interface","title":"DiffEqNoiseProcess.REAL_WHITE_NOISE_DIST","text":"REAL_WHITE_NOISE_DIST(dW, W, dt, u, p, t, rng)\n\nGenerate real-valued white noise distributed according to N(0, dt).\n\nUnlike WHITENOISEDIST, this function always generates real-valued noise, even if the input type would normally support complex values.\n\nArguments\n\ndW: Noise increment container\nW: Current noise value (unused for white noise)\ndt: Time step\nu: Current state (for state-dependent noise)\np: Parameters\nt: Current time\nrng: Random number generator\n\nReturns\n\nReal-valued random numbers distributed as N(0, dt), scaled by √dt\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.REAL_WHITE_NOISE_BRIDGE","page":"Noise Process Interface","title":"DiffEqNoiseProcess.REAL_WHITE_NOISE_BRIDGE","text":"REAL_WHITE_NOISE_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate real-valued white noise for Brownian bridge interpolation.\n\nThis function ensures the generated noise is always real-valued, even for complex-valued endpoints.\n\nArguments\n\ndW: Noise increment container\nW: Current noise value\nW0: Starting noise value\nWh: Target noise value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nReturns\n\nReal-valued interpolated noise value\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_DIST","page":"Noise Process Interface","title":"DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_DIST","text":"REAL_INPLACE_WHITE_NOISE_DIST(rand_vec, W, dt, u, p, t, rng)\n\nGenerate real-valued white noise distributed according to N(0, dt) in-place.\n\nThis is the in-place version of REALWHITENOISE_DIST.\n\nArguments\n\nrand_vec: Array to fill with noise values\nW: Current noise value (unused for white noise)\ndt: Time step\nu: Current state (for state-dependent noise)\np: Parameters\nt: Current time\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain real-valued random numbers distributed as N(0, dt)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_BRIDGE","page":"Noise Process Interface","title":"DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_BRIDGE","text":"REAL_INPLACE_WHITE_NOISE_BRIDGE(rand_vec, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate real-valued white noise for Brownian bridge interpolation in-place.\n\nThis is the in-place version of REALWHITENOISE_BRIDGE.\n\nArguments\n\nrand_vec: Array to fill with interpolated noise values\nW: Current noise value\nW0: Starting noise value\nWh: Target noise value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain real-valued interpolated noise values\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.wiener_randn","page":"Noise Process Interface","title":"DiffEqNoiseProcess.wiener_randn","text":"wiener_randn(rng::AbstractRNG, ::Type{T}) where {T}\n\nGenerate a random number from the standard normal distribution for type T.\n\nArguments\n\nrng: Random number generator\nT: Type of the random number to generate\n\nReturns\n\nA random number of type T from the standard normal distribution\n\n\n\n\n\nwiener_randn(rng::AbstractRNG, proto::AbstractArray{T}) where {T <: Number}\n\nGenerate an array of random numbers from the standard normal distribution, matching the size of the prototype array.\n\nArguments\n\nrng: Random number generator\nproto: Prototype array whose size determines the output size\n\nReturns\n\nAn array of random numbers from the standard normal distribution with the same size as proto\n\n\n\n\n\nwiener_randn(rng::AbstractRNG, proto::T) where {T <: StaticArraysCore.SArray}\n\nGenerate a static array of random numbers from the standard normal distribution.\n\nArguments\n\nrng: Random number generator\nproto: Prototype static array\n\nReturns\n\nA static array of the same type as proto filled with standard normal random numbers\n\n\n\n\n\nwiener_randn(rng::AbstractRNG, proto)\n\nGenerate random numbers from the standard normal distribution for arbitrary types.\n\nArguments\n\nrng: Random number generator\nproto: Prototype object whose type and size determine the output\n\nReturns\n\nRandom values converted to the same type as proto\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.wiener_randn!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.wiener_randn!","text":"wiener_randn!(rng::AbstractRNG, rand_vec::AbstractArray)\n\nFill an array with random numbers from the standard normal distribution in-place.\n\nArguments\n\nrng: Random number generator\nrand_vec: Array to fill with random values\n\nReturns\n\nThe modified rand_vec filled with standard normal random numbers\n\n\n\n\n\nwiener_randn!(rng::AbstractRNG, rand_vec)\n\nFill an arbitrary container with random numbers from the standard normal distribution in-place using broadcasting.\n\nArguments\n\nrng: Random number generator (not used in this fallback)\nrand_vec: Container to fill with random values\n\nReturns\n\nThe modified rand_vec filled with standard normal random numbers\n\n\n\n\n\nwiener_randn!(rng::AbstractRNG, rand_vec::GPUArraysCore.AbstractGPUArray)\n\nFill a GPU array with random numbers from the standard normal distribution in-place.\n\nThis specialized method works for GPUs because it doesn't pass the RNG to the GPU kernel, which may not be supported on all GPU backends.\n\nArguments\n\nrng: Random number generator (not passed to GPU)\nrand_vec: GPU array to fill with random values\n\nReturns\n\nThe modified rand_vec filled with standard normal random numbers\n\n\n\n\n\nwiener_randn!(y::AbstractRNG, x::AbstractArray{<:Complex{T}}) where {T <: Number}\n\nFill an array of complex numbers with random values from the standard complex normal distribution in-place.\n\nEach complex number is generated as (a + bi)/√2 where a and b are independent standard normal random variables.\n\nArguments\n\ny: Random number generator\nx: Array of complex numbers to fill\n\nReturns\n\nThe modified array filled with complex normal random numbers\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.OrnsteinUhlenbeck","page":"Noise Process Interface","title":"DiffEqNoiseProcess.OrnsteinUhlenbeck","text":"OrnsteinUhlenbeck{T1, T2, T3}\n\nParameters for the Ornstein-Uhlenbeck process.\n\nFields\n\nΘ: Mean reversion rate (higher values mean faster reversion)\nμ: Long-term mean (the value the process reverts to)\nσ: Volatility/diffusion coefficient\n\nThe process follows the SDE: dXt = Θ(μ - Xt)dt + σ dW_t\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.OrnsteinUhlenbeck!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.OrnsteinUhlenbeck!","text":"OrnsteinUhlenbeck!{T1, T2, T3}\n\nIn-place version of OrnsteinUhlenbeck parameters.\n\nFields\n\nΘ: Mean reversion rate (higher values mean faster reversion)\nμ: Long-term mean (the value the process reverts to)\nσ: Volatility/diffusion coefficient\n\nThe process follows the SDE: dXt = Θ(μ - Xt)dt + σ dW_t\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.ou_bridge","page":"Noise Process Interface","title":"DiffEqNoiseProcess.ou_bridge","text":"ou_bridge(dW, ou, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate Ornstein-Uhlenbeck bridge interpolation between two points.\n\nProvides exact sampling from an OU process conditioned on both endpoints, useful for adaptive time-stepping and interpolation.\n\nArguments\n\ndW: Noise increment container\nou: OrnsteinUhlenbeck parameters\nW: Current noise process state\nW0: Starting value\nWh: Target value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nReturns\n\nInterpolated OU process value that maintains the correct distribution\n\nReferences\n\nhttp://www.tandfonline.com/doi/pdf/10.1080/14697688.2014.941913\nhttps://arxiv.org/pdf/1011.0067.pdf (page 18)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.ou_bridge!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.ou_bridge!","text":"ou_bridge!(rand_vec, ou, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate Ornstein-Uhlenbeck bridge interpolation in-place.\n\nThis is the in-place version of ou_bridge, modifying the provided array rather than allocating a new one.\n\nArguments\n\nrand_vec: Array to fill with interpolated values\nou: OrnsteinUhlenbeck parameters\nW: Current noise process state\nW0: Starting value\nWh: Target value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain the interpolated OU process values\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.GeometricBrownianMotion","page":"Noise Process Interface","title":"DiffEqNoiseProcess.GeometricBrownianMotion","text":"GeometricBrownianMotion{T1, T2}\n\nParameters for the geometric Brownian motion process.\n\nFields\n\nμ: Drift parameter (expected return rate)\nσ: Volatility parameter (standard deviation of returns)\n\nThe process follows the SDE: dXt = μXt dt + σXt dWt\n\nThis is commonly used in financial models, particularly the Black-Scholes model.\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.GeometricBrownianMotion!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.GeometricBrownianMotion!","text":"GeometricBrownianMotion!{T1, T2}\n\nIn-place version of GeometricBrownianMotion parameters.\n\nFields\n\nμ: Drift parameter (expected return rate)\nσ: Volatility parameter (standard deviation of returns)\n\nThe process follows the SDE: dXt = μXt dt + σXt dWt\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.gbm_bridge","page":"Noise Process Interface","title":"DiffEqNoiseProcess.gbm_bridge","text":"gbm_bridge(dW, gbm, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate geometric Brownian motion bridge interpolation between two points.\n\nProvides exact sampling from a GBM process conditioned on both endpoints, useful for adaptive time-stepping and interpolation.\n\nArguments\n\ndW: Noise increment container\ngbm: GeometricBrownianMotion parameters\nW: Current noise process state\nW0: Starting value\nWh: Target value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nReturns\n\nInterpolated GBM process value that maintains the correct log-normal distribution\n\nReference\n\nhttps://math.stackexchange.com/questions/412470/conditional-distribution-in-brownian-motion\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.gbm_bridge!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.gbm_bridge!","text":"gbm_bridge!(rand_vec, gbm, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate geometric Brownian motion bridge interpolation in-place.\n\nThis is the in-place version of gbm_bridge, modifying the provided array rather than allocating a new one.\n\nArguments\n\nrand_vec: Array to fill with interpolated values\ngbm: GeometricBrownianMotion parameters\nW: Current noise process state\nW0: Starting value\nWh: Target value at end of interval\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nEffects\n\nModifies rand_vec to contain the interpolated GBM process values\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.CompoundPoissonProcess","page":"Noise Process Interface","title":"DiffEqNoiseProcess.CompoundPoissonProcess","text":"CompoundPoissonProcess{R, CR}\n\nA compound Poisson process for modeling jump processes.\n\nThe process has jumps that occur according to a Poisson process with given rate, and jump sizes determined by a specified distribution.\n\nFields\n\nrate: Jump rate function or constant (λ parameter)\ncurrate: Current rate value (cached for efficiency)\ncomputerates: Whether to recompute rates at each step\n\nConstructor\n\nCompoundPoissonProcess(rate, t0, W0; computerates = true, kwargs...)\n\nExamples\n\n# Constant rate\nproc = CompoundPoissonProcess(2.0, 0.0, 0.0)\n\n# Time-dependent rate\nrate_func(u, p, t) = 1.0 + 0.5*sin(t)\nproc = CompoundPoissonProcess(rate_func, 0.0, 0.0)\n\nReferences\n\nhttps://www.math.wisc.edu/~anderson/papers/AndPostleap.pdf Incorporating postleap checks in tau-leaping J. Chem. Phys. 128, 054103 (2008); https://doi.org/10.1063/1.2819665\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.CompoundPoissonProcess!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.CompoundPoissonProcess!","text":"CompoundPoissonProcess!{R, CR}\n\nIn-place version of CompoundPoissonProcess.\n\nSee CompoundPoissonProcess for details.\n\nConstructor\n\nCompoundPoissonProcess!(rate, t0, W0; computerates = true, kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"api/interface/#DiffEqNoiseProcess.cpp_bridge","page":"Noise Process Interface","title":"DiffEqNoiseProcess.cpp_bridge","text":"cpp_bridge(dW, cpp, W, W0, Wh, q, h, u, p, t, rng)\n\nGenerate compound Poisson process bridge interpolation between two points.\n\nUses binomial thinning to distribute jumps appropriately between endpoints.\n\nArguments\n\ndW: Noise increment container\ncpp: CompoundPoissonProcess parameters\nW: Current noise process state\nW0: Starting value\nWh: Jump count difference (must be integer)\nq: Interpolation parameter (0 to 1)\nh: Total time interval\nu, p, t: State, parameters, and time (for compatibility)\nrng: Random number generator\n\nReturns\n\nNumber of jumps distributed according to binomial thinning\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#DiffEqNoiseProcess.cpp_bridge!","page":"Noise Process Interface","title":"DiffEqNoiseProcess.cpp_bridge!","text":"cpp_bridge!(rand_vec, cpp, W, W0, Wh, q, h, u, p, t, rng)\n\nIn-place version of cpp_bridge.\n\nEffects\n\nModifies rand_vec to contain binomially distributed jump counts\n\n\n\n\n\n","category":"function"},{"location":"tutorials/advanced_features/#Advanced-Features","page":"Advanced Features","title":"Advanced Features","text":"This tutorial covers the advanced functionality in DiffEqNoiseProcess.jl, including custom noise processes, wrappers, and memory-efficient alternatives.","category":"section"},{"location":"tutorials/advanced_features/#Custom-Noise-from-Functions","page":"Advanced Features","title":"Custom Noise from Functions","text":"","category":"section"},{"location":"tutorials/advanced_features/#NoiseFunction","page":"Advanced Features","title":"NoiseFunction","text":"Create noise processes from arbitrary functions of time:\n\nusing DiffEqNoiseProcess, SciMLBase\nusing Random\n\n# Define a deterministic \"noise\" function\n# NoiseFunction expects signature f(u, p, t)\nfunction my_noise_func(u, p, t)\n    return sin(2π * t) + 0.1 * cos(10π * t)\nend\n\n# Create noise process from function (t0, function)\nnoise_func = NoiseFunction(0.0, my_noise_func)\n\n# Test the function\nprob = NoiseProblem(noise_func, (0.0, 2.0))\nsol = solve(prob; dt = 0.01)\n\nprintln(\"NoiseFunction example completed successfully!\")\n# Access values via callable interface: sol(t) returns (W, Z) tuple\nprintln(\"Value at t=0.5: $(sol(0.5)[1])\")\nprintln(\"Value at t=1.0: $(sol(1.0)[1])\")","category":"section"},{"location":"tutorials/advanced_features/#NoiseTransport","page":"Advanced Features","title":"NoiseTransport","text":"Transport a random variable through a time-dependent function:\n\n# Transport function: signature is f(u, p, t, rv) where rv is the random variable\n# This creates noise W(t) = ξ * exp(-0.5t) * cos(t) where ξ ~ N(0,1)\nfunction transport_func(u, p, t, ξ)\n    return ξ * exp(-0.5 * t) * cos(t)\nend\n\n# Create transported noise: NoiseTransport(t0, f, RV)\n# RV is a function that generates random values (like randn)\nnoise_transport = NoiseTransport(0.0, transport_func, randn)\n\nprob_transport = NoiseProblem(noise_transport, (0.0, 3π))\nsol_transport = solve(prob_transport; dt = 0.01)\n\n# NoiseTransport computes values on-the-fly; access via callable interface\n# Returns (W_value, Z_value) tuple, use [1] to get W\nprintln(\"Transported at t=0: $(sol_transport(0.0)[1])\")\nprintln(\"Transported at t=π: $(sol_transport(π)[1])\")","category":"section"},{"location":"tutorials/advanced_features/#Noise-from-Data","page":"Advanced Features","title":"Noise from Data","text":"","category":"section"},{"location":"tutorials/advanced_features/#NoiseGrid","page":"Advanced Features","title":"NoiseGrid","text":"Create noise processes from pre-computed data points:\n\n# Generate some data (e.g., from experimental measurements)\nt_data = collect(0.0:0.1:1.0)\nnoise_data = cumsum(randn(length(t_data)) * sqrt(0.1))  # Approximate Brownian motion\n\n# Create noise process from grid\nnoise_grid = NoiseGrid(t_data, noise_data)\n\n# Use it in a problem\nprob_grid = NoiseProblem(noise_grid, (0.0, 1.0))\nsol_grid = solve(prob_grid; dt = 0.05)\n\nprintln(\"Grid noise interpolated values:\")\nfor t in [0.0, 0.25, 0.5, 0.75, 1.0]\n    println(\"  t=$t: $(sol_grid(t))\")\nend","category":"section"},{"location":"tutorials/advanced_features/#Memory-Efficient-Alternatives","page":"Advanced Features","title":"Memory-Efficient Alternatives","text":"","category":"section"},{"location":"tutorials/advanced_features/#VirtualBrownianTree","page":"Advanced Features","title":"VirtualBrownianTree","text":"For memory-constrained applications, use a virtual Brownian tree that generates values on-demand:\n\n# Create a virtual Brownian tree\n# VirtualBrownianTree(t0, W0; tree_depth, atol, ...)\n# tree_depth controls the cache size for speed/memory tradeoff\nvbt = VirtualBrownianTree(0.0, 0.0; tree_depth = 5, atol = 1e-6)\n\n# The tree generates Brownian motion values on demand without storing them\nprob_vbt = NoiseProblem(vbt, (0.0, 1.0))\nsol_vbt = solve(prob_vbt; dt = 0.01)\n\nprintln(\"VBT memory usage is O(tree_depth) regardless of path length\")\nprintln(\"Final VBT value: $(sol_vbt.u[end])\")","category":"section"},{"location":"tutorials/advanced_features/#Noise-Process-Wrappers","page":"Advanced Features","title":"Noise Process Wrappers","text":"","category":"section"},{"location":"tutorials/advanced_features/#NoiseWrapper","page":"Advanced Features","title":"NoiseWrapper","text":"Reuse noise from previous simulations in a distributionally-exact manner:\n\n# First, generate a reference noise process\nW_ref = WienerProcess(0.0, 0.0, 1.0)\nprob_ref = NoiseProblem(W_ref, (0.0, 1.0))\nsol_ref = solve(prob_ref; dt = 0.1)  # Coarse timestep\n\nprintln(\"Reference solution has $(length(sol_ref.t)) points\")\n\n# Now wrap it to use at different timesteps\n# Note: solve(NoiseProblem(...)) returns the noise process directly\nwrapped_noise = NoiseWrapper(sol_ref)\n\n# Use the wrapped noise with finer timestep\nprob_wrapped = NoiseProblem(wrapped_noise, (0.0, 1.0))\nsol_wrapped = solve(prob_wrapped; dt = 0.01)  # Fine timestep\n\nprintln(\"Wrapped solution has $(length(sol_wrapped.t)) points\")\nprintln(\"Both solutions follow the same stochastic trajectory\")\n\n# Verify they agree at common timepoints\n# Note: WienerProcess(t0, W0, Z0) returns tuples (W, Z), so we access [1] for W\nfor t in [0.0, 0.5, 1.0]\n    ref_val = sol_ref(t)[1]\n    wrapped_val = sol_wrapped(t)[1]\n    println(\"At t=$t: ref=$(round(ref_val, digits=6)), wrapped=$(round(wrapped_val, digits=6))\")\nend","category":"section"},{"location":"tutorials/advanced_features/#Approximation-Methods","page":"Advanced Features","title":"Approximation Methods","text":"","category":"section"},{"location":"tutorials/advanced_features/#NoiseApproximation","page":"Advanced Features","title":"NoiseApproximation","text":"Approximate colored noise as solutions to SDEs. NoiseApproximation takes a DEIntegrator from an SDE solve, allowing you to use SDE solutions as noise processes. This is useful for creating correlated or colored noise.\n\n# NoiseApproximation requires StochasticDiffEq for the SDE integrator\n# Here we show a conceptual example - in practice you would do:\n#\n# using StochasticDiffEq\n# f(u, p, t) = -u          # Mean reversion (drift)\n# g(u, p, t) = 0.5         # Constant diffusion\n# sde_prob = SDEProblem(f, g, 1.0, (0.0, Inf))\n# integrator = init(sde_prob, SRIW1())\n# noise_approx = NoiseApproximation(integrator)\n#\n# Then use noise_approx as a noise process in another problem\n\nprintln(\"NoiseApproximation requires a DEIntegrator from StochasticDiffEq\")\nprintln(\"See the API documentation for full usage examples\")","category":"section"},{"location":"tutorials/advanced_features/#Process-Configuration","page":"Advanced Features","title":"Process Configuration","text":"","category":"section"},{"location":"tutorials/advanced_features/#Process-Reset-and-Reuse","page":"Advanced Features","title":"Process Reset and Reuse","text":"# Create a process and use it\nW_reusable = WienerProcess(0.0, 0.0, 1.0)\nprob1 = NoiseProblem(W_reusable, (0.0, 1.0))\nsol1 = solve(prob1; dt = 0.1)\n\nprintln(\"First use - final value: $(sol1.u[end])\")\n\n# Reinitialize and reuse the same process\nreinit!(W_reusable, 0.1)  # Reinitialize with dt=0.1\nprob2 = NoiseProblem(W_reusable, (0.0, 1.0))\nsol2 = solve(prob2; dt = 0.1)\n\nprintln(\"After reinit - final value: $(sol2.u[end])\")\nprintln(\"Values are different due to reinitialization\")","category":"section"},{"location":"tutorials/advanced_features/#Performance-Considerations","page":"Advanced Features","title":"Performance Considerations","text":"Choose the appropriate noise process type based on your application needs:\n\nIn-place versions: Use in-place versions (Process!) for large systems to reduce allocations\nVirtualBrownianTree: Use for memory-constrained applications where O(1) memory is critical\nNoiseGrid: Use for pre-computed data or when you have experimental measurements\nNoiseWrapper: Use to reuse expensive computations across multiple simulations with different timesteps","category":"section"},{"location":"tutorials/basic_usage/#Basic-Usage-Tutorial","page":"Basic Usage Tutorial","title":"Basic Usage Tutorial","text":"This tutorial covers the fundamental usage patterns of DiffEqNoiseProcess.jl, including creating noise processes, using them in problems, and direct simulation.","category":"section"},{"location":"tutorials/basic_usage/#Creating-and-Using-Noise-Processes","page":"Basic Usage Tutorial","title":"Creating and Using Noise Processes","text":"","category":"section"},{"location":"tutorials/basic_usage/#Basic-Wiener-Process","page":"Basic Usage Tutorial","title":"Basic Wiener Process","text":"A Wiener process (Brownian motion) is the most fundamental noise process:\n\nusing DiffEqNoiseProcess, SciMLBase\n\n# Create a standard Wiener process\n# Parameters: t0 (start time), W0 (initial value), Z0 (end value)\nW = WienerProcess(0.0, 0.0, 1.0)\n\n# You can specify additional options\nW_custom = WienerProcess(0.0, 0.0, 1.0; \n                        save_everystep = true,\n                        rswm = RSWM())","category":"section"},{"location":"tutorials/basic_usage/#Real-Valued-Wiener-Process","page":"Basic Usage Tutorial","title":"Real-Valued Wiener Process","text":"For scalar problems, use a real-valued Wiener process:\n\n# Real-valued Wiener process  \nW_real = RealWienerProcess(0.0, 0.0, 1.0)","category":"section"},{"location":"tutorials/basic_usage/#Geometric-Brownian-Motion","page":"Basic Usage Tutorial","title":"Geometric Brownian Motion","text":"A geometric Brownian motion process is useful for financial modeling:\n\n# Parameters: μ (drift), σ (volatility), t0, W0, Z0\nμ = 0.05  # 5% drift\nσ = 0.2   # 20% volatility\nGBM = GeometricBrownianMotionProcess(μ, σ, 0.0, 1.0, 1.0)","category":"section"},{"location":"tutorials/basic_usage/#Using-Noise-in-SDE-Problems","page":"Basic Usage Tutorial","title":"Using Noise in SDE Problems","text":"Noise processes can be passed directly to SDE problems:\n\n# Define a simple SDE: du = u*dt + 0.1*u*dW\nfunction f(u, p, t)\n    return u\nend\n\nfunction g(u, p, t)\n    return 0.1 * u\nend\n\nu0 = 1.0\ntspan = (0.0, 1.0)\n\n# Create the problem with custom noise\nprob = SDEProblem(f, g, u0, tspan, noise = W)","category":"section"},{"location":"tutorials/basic_usage/#Direct-Simulation","page":"Basic Usage Tutorial","title":"Direct Simulation","text":"You can simulate noise processes directly without solving an SDE:\n\n# Create a noise problem\nprob = NoiseProblem(W, (0.0, 1.0))\n\n# Solve it with a specified timestep\nsol = solve(prob; dt = 0.01)\n\n# Access the noise values\nprintln(\"Final noise value: \", sol.u[end])\nprintln(\"Number of steps: \", length(sol.t))","category":"section"},{"location":"tutorials/basic_usage/#Ensemble-Simulations","page":"Basic Usage Tutorial","title":"Ensemble Simulations","text":"Generate multiple realizations of the same noise process:\n\n# Create ensemble problem\nenprob = EnsembleProblem(prob)\n\n# Generate 100 trajectories\nensol = solve(enprob; dt = 0.01, trajectories = 100)\n\nprintln(\"Generated $(length(ensol.u)) noise trajectories\")","category":"section"},{"location":"tutorials/basic_usage/#Direct-Interface-for-Advanced-Usage","page":"Basic Usage Tutorial","title":"Direct Interface for Advanced Usage","text":"For advanced users, noise processes support a direct stepping interface:\n\n# Create a fresh Wiener process\nW_direct = WienerProcess(0.0, 0.0, 1.0)\n\n# Set the timestep\ndt = 0.1\nW_direct.dt = dt\n\n# For state-dependent noise (not applicable here, but required by interface)\nu = nothing\np = nothing\n\n# Calculate and accept steps\ncalculate_step!(W_direct, dt, u, p)\nfor i in 1:5\n    accept_step!(W_direct, dt, u, p)\n    println(\"Step $i: W = $(W_direct.curW)\")\nend\n\nThis direct interface is primarily used internally by the SDE solvers but can be useful for custom implementations.","category":"section"},{"location":"#DiffEqNoiseProcess.jl:-Noise-Processes-for-Stochastic-Modeling","page":"Home","title":"DiffEqNoiseProcess.jl: Noise Processes for Stochastic Modeling","text":"DiffEqNoiseProcess.jl provides a comprehensive suite of noise processes for stochastic differential equations and random differential equations. The NoiseProcess types are distributionally-exact, meaning they are generated directly according to their analytical distributions rather than as solutions to SDEs.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Mathematically rigorous: All processes maintain distributional exactness\nComprehensive collection: Wiener processes, Ornstein-Uhlenbeck, geometric Brownian motion, compound Poisson, and more\nFlexible interface: Works seamlessly with the DifferentialEquations.jl ecosystem\nMemory efficient: Includes virtual processes and wrappers for large-scale simulations\nBridging support: Conditional processes for specific boundary conditions","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install DiffEqNoiseProcess.jl, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"DiffEqNoiseProcess\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Wiener-Process","page":"Home","title":"Basic Wiener Process","text":"Create and simulate a standard Brownian motion:\n\nusing DiffEqNoiseProcess, SciMLBase\n\n# Create a Wiener process: WienerProcess(t0, W0, Z0)\nW = WienerProcess(0.0, 0.0, 1.0)\n\n# Simulate it over time interval [0, 1] \nprob = NoiseProblem(W, (0.0, 1.0))\nsol = solve(prob; dt = 0.01)\n\nprintln(\"Final Brownian motion value: $(sol.u[end])\")","category":"section"},{"location":"#Using-Noise-in-SDE-Problems","page":"Home","title":"Using Noise in SDE Problems","text":"Noise processes integrate directly with SDE problems:\n\nusing SciMLBase\n\n# Define SDE: dX = μX dt + σX dW (geometric Brownian motion)\nf(u, p, t) = 0.05 * u  # 5% drift\ng(u, p, t) = 0.2 * u   # 20% volatility\n\n# Use custom geometric Brownian motion noise\ngbm_noise = GeometricBrownianMotionProcess(0.05, 0.2, 0.0, 100.0, 100.0)\n\n# Create SDE problem (would normally solve this)\n# prob = SDEProblem(f, g, 100.0, (0.0, 1.0), noise = gbm_noise)","category":"section"},{"location":"#Ensemble-Simulations","page":"Home","title":"Ensemble Simulations","text":"Generate multiple noise realizations:\n\n# Create ensemble problem for Monte Carlo simulation\nenprob = EnsembleProblem(prob)\nensemble_sol = solve(enprob; dt = 0.01, trajectories = 100)\n\nprintln(\"Generated $(length(ensemble_sol.u)) noise trajectories\")","category":"section"},{"location":"#Available-Noise-Processes","page":"Home","title":"Available Noise Processes","text":"DiffEqNoiseProcess.jl includes a rich collection of noise processes:","category":"section"},{"location":"#Classic-Processes","page":"Home","title":"Classic Processes","text":"WienerProcess: Standard Brownian motion\nRealWienerProcess: Scalar Brownian motion\nCorrelatedWienerProcess: Multi-dimensional correlated noise\nOrnsteinUhlenbeckProcess: Mean-reverting process\nGeometricBrownianMotionProcess: For financial modeling\nCompoundPoissonProcess: Jump processes","category":"section"},{"location":"#Bridge-Processes","page":"Home","title":"Bridge Processes","text":"BrownianBridge: Brownian motion with fixed endpoints\nGeometricBrownianBridge: GBM with boundary conditions","category":"section"},{"location":"#Advanced-Features","page":"Home","title":"Advanced Features","text":"NoiseFunction: Custom noise from functions\nNoiseGrid: Noise from pre-computed data\nNoiseWrapper: Reuse previous simulations\nVirtualBrownianTree: Memory-efficient alternative\nNoiseApproximation: Colored noise via SDE solutions","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"This documentation is organized as follows:\n\nBasic Usage Tutorial: Get started with fundamental concepts\nNoise Process Types: Comprehensive guide to all available processes\nAdvanced Features: Custom processes, wrappers, and optimization\nAPI Reference: Complete function and type documentation\nInterface API: Step management and internal functions","category":"section"},{"location":"#Mathematical-Foundation","page":"Home","title":"Mathematical Foundation","text":"All noise processes in this package maintain mathematical rigor through:\n\nDistributional exactness: Processes follow their theoretical distributions exactly\nRejection Sampling with Memory (RSWM): Ensures correctness when adaptive stepping is used\nProper bridging: Conditional processes respect boundary conditions\nInterpolation consistency: Values between grid points maintain distributional properties","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages<!– ignore linkcheck –> for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"},{"location":"tutorials/noise_processes/#Noise-Process-Types","page":"Noise Process Types","title":"Noise Process Types","text":"This tutorial demonstrates the various types of noise processes available in DiffEqNoiseProcess.jl and their specific use cases.","category":"section"},{"location":"tutorials/noise_processes/#Standard-Brownian-Motion","page":"Noise Process Types","title":"Standard Brownian Motion","text":"","category":"section"},{"location":"tutorials/noise_processes/#Wiener-Process","page":"Noise Process Types","title":"Wiener Process","text":"The standard Wiener process is the foundation of stochastic calculus:\n\nusing DiffEqNoiseProcess, SciMLBase, Random, Distributions\nusing Statistics\n\n# Set seed for reproducibility\nRandom.seed!(123)\n\n# Standard Wiener process\nW = WienerProcess(0.0, 0.0, 1.0)\n\n# Simulate it\nprob = NoiseProblem(W, (0.0, 2.0))\nsol = solve(prob; dt = 0.01)\n\nprintln(\"Final value: $(sol.u[end])\")\nprintln(\"Path length: $(length(sol.t))\")","category":"section"},{"location":"tutorials/noise_processes/#Correlated-Wiener-Process","page":"Noise Process Types","title":"Correlated Wiener Process","text":"For multi-dimensional systems with correlated noise:\n\n# 2D correlated Wiener process with correlation matrix\nΓ = [1.0 0.5; 0.5 1.0]  # Correlation matrix\nW0 = [0.0, 0.0]         # Initial values\nZ0 = [1.0, 1.0]         # Final values\n\ncorr_W = CorrelatedWienerProcess(Γ, 0.0, W0, Z0)\n\n# Simulate\nprob_corr = NoiseProblem(corr_W, (0.0, 1.0))\nsol_corr = solve(prob_corr; dt = 0.01)\n\nprintln(\"Final 2D noise: $(sol_corr.u[end])\")","category":"section"},{"location":"tutorials/noise_processes/#Mean-Reverting-Processes","page":"Noise Process Types","title":"Mean-Reverting Processes","text":"","category":"section"},{"location":"tutorials/noise_processes/#Ornstein-Uhlenbeck-Process","page":"Noise Process Types","title":"Ornstein-Uhlenbeck Process","text":"Models mean-reverting behavior, which is commonly used in interest rate models:\n\n# Parameters: Θ (mean reversion rate), μ (long-term mean), σ (volatility)\nΘ = 2.0   # Fast mean reversion\nμ = 0.5   # Mean level\nσ = 0.3   # Volatility\n\nOU = OrnsteinUhlenbeckProcess(Θ, μ, σ, 0.0, 0.0, 1.0)\n\n# Simulate\nprob_ou = NoiseProblem(OU, (0.0, 5.0))\nsol_ou = solve(prob_ou; dt = 0.01)\n\nprintln(\"OU process starts at: $(sol_ou.u[1])\")\nprintln(\"OU process ends at: $(sol_ou.u[end])\")\nprintln(\"Long-term mean μ: $μ\")","category":"section"},{"location":"tutorials/noise_processes/#Jump-Processes","page":"Noise Process Types","title":"Jump Processes","text":"","category":"section"},{"location":"tutorials/noise_processes/#Compound-Poisson-Process","page":"Noise Process Types","title":"Compound Poisson Process","text":"Models discontinuous jumps at random times:\n\n# Parameters: λ (jump rate)\nλ = 2.0  # 2 jumps per unit time on average\n\n# Create compound Poisson process with constant rate\n# Use computerates=false for constant rate values\npoisson_proc = CompoundPoissonProcess(λ, 0.0, 0.0; computerates = false)\n\n# Simulate\nprob_poisson = NoiseProblem(poisson_proc, (0.0, 2.0))\nsol_poisson = solve(prob_poisson; dt = 0.01)\n\nprintln(\"Final Poisson process value: $(sol_poisson.u[end])\")\n\n# Count number of jumps (non-zero increments)\njumps = sum(abs.(diff(sol_poisson.u)) .> 1e-10)\nprintln(\"Number of jumps: $jumps\")","category":"section"},{"location":"tutorials/noise_processes/#Financial-Models","page":"Noise Process Types","title":"Financial Models","text":"","category":"section"},{"location":"tutorials/noise_processes/#Geometric-Brownian-Motion","page":"Noise Process Types","title":"Geometric Brownian Motion","text":"The classic Black-Scholes model for stock prices:\n\n# Stock parameters\nμ_stock = 0.08   # 8% expected return\nσ_stock = 0.25   # 25% volatility\nS0 = 100.0       # Initial stock price\n\nGBM = GeometricBrownianMotionProcess(μ_stock, σ_stock, 0.0, S0, S0)\n\n# Simulate stock price over 1 year\nprob_gbm = NoiseProblem(GBM, (0.0, 1.0))\nsol_gbm = solve(prob_gbm; dt = 1/252)  # Daily steps\n\nprintln(\"Initial stock price: $(sol_gbm.u[1])\")\nprintln(\"Final stock price: $(sol_gbm.u[end])\")\nprintln(\"Return: $((sol_gbm.u[end] - sol_gbm.u[1])/sol_gbm.u[1] * 100)%\")","category":"section"},{"location":"tutorials/noise_processes/#Bridge-Processes","page":"Noise Process Types","title":"Bridge Processes","text":"Bridge processes are conditioned to pass through specific values:","category":"section"},{"location":"tutorials/noise_processes/#Brownian-Bridge","page":"Noise Process Types","title":"Brownian Bridge","text":"A Wiener process conditioned to start and end at specific values:\n\n# Bridge from 0 at t=0 to 1 at t=1\nbridge = BrownianBridge(0.0, 1.0, 0.0, 1.0)\n\nprob_bridge = NoiseProblem(bridge, (0.0, 1.0))\nsol_bridge = solve(prob_bridge; dt = 0.01)\n\nprintln(\"Bridge starts at: $(sol_bridge.u[1])\")\nprintln(\"Bridge ends at: $(sol_bridge.u[end])\")\nprintln(\"Should be exactly 0 and 1 respectively\")","category":"section"},{"location":"tutorials/noise_processes/#Geometric-Brownian-Bridge","page":"Noise Process Types","title":"Geometric Brownian Bridge","text":"A geometric Brownian motion conditioned on endpoints:\n\n# Bridge parameters\nμ_bridge = 0.05\nσ_bridge = 0.2\nstart_val = 100.0\nend_val = 110.0\n\ngbm_bridge = GeometricBrownianBridge(μ_bridge, σ_bridge, 0.0, start_val, 1.0, end_val)\n\nprob_gbm_bridge = NoiseProblem(gbm_bridge, (0.0, 1.0))\nsol_gbm_bridge = solve(prob_gbm_bridge; dt = 0.01)\n\nprintln(\"GBM bridge starts at: $(sol_gbm_bridge.u[1])\")\nprintln(\"GBM bridge ends at: $(sol_gbm_bridge.u[end])\")","category":"section"},{"location":"tutorials/noise_processes/#Process-Comparisons","page":"Noise Process Types","title":"Process Comparisons","text":"Let's compare different noise processes visually by looking at their statistical properties:\n\nusing Statistics\n\n# Generate multiple realizations for statistical analysis\nfunction analyze_process(noise_process, name, n_paths=1000)\n    final_values = Float64[]\n    \n    for i in 1:n_paths\n        # Reset the process for each simulation\n        reset_process = typeof(noise_process)(noise_process.params...)\n        prob = NoiseProblem(reset_process, (0.0, 1.0))\n        sol = solve(prob; dt = 0.01)\n        push!(final_values, sol.u[end])\n    end\n    \n    println(\"$name Statistics (after t=1):\")\n    println(\"  Mean: $(round(mean(final_values), digits=4))\")\n    println(\"  Std:  $(round(std(final_values), digits=4))\")\n    println(\"  Min:  $(round(minimum(final_values), digits=4))\")\n    println(\"  Max:  $(round(maximum(final_values), digits=4))\")\n    println()\n    \n    return final_values\nend\n\n# Note: This analysis would require process constructors to be callable\n# For demonstration, we'll just show the concept\nprintln(\"Statistical analysis concept:\")\nprintln(\"- Wiener process: Mean ≈ 0, increasing variance with time\")\nprintln(\"- OU process: Mean reverts to long-term level\")  \nprintln(\"- GBM: Log-normal distribution of final values\")\nprintln(\"- Compound Poisson: Discrete jumps, possibly skewed distribution\")\n\nEach noise process has unique characteristics suitable for different modeling scenarios. Choose based on your specific application needs.","category":"section"},{"location":"noise_processes/#Classic-Noise-Processes","page":"Classic Noise Processes","title":"Classic Noise Processes","text":"This section describes the available NoiseProcess types. Note that all keyword arguments are splatted into the NoiseProcess constructor, and thus options like reset are available on the pre-built processes.","category":"section"},{"location":"noise_processes/#Bridges","page":"Classic Noise Processes","title":"Bridges","text":"","category":"section"}]
}
