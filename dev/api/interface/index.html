<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise Process Interface · DiffEqNoiseProcess.jl</title><meta name="title" content="Noise Process Interface · DiffEqNoiseProcess.jl"/><meta property="og:title" content="Noise Process Interface · DiffEqNoiseProcess.jl"/><meta property="twitter:title" content="Noise Process Interface · DiffEqNoiseProcess.jl"/><meta name="description" content="Documentation for DiffEqNoiseProcess.jl."/><meta property="og:description" content="Documentation for DiffEqNoiseProcess.jl."/><meta property="twitter:description" content="Documentation for DiffEqNoiseProcess.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqNoiseProcess/stable/api/interface/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqNoiseProcess/stable/api/interface/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqNoiseProcess/stable/api/interface/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DiffEqNoiseProcess.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffEqNoiseProcess.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/basic_usage/">Basic Usage Tutorial</a></li><li><a class="tocitem" href="../../tutorials/noise_processes/">Noise Process Types</a></li><li><a class="tocitem" href="../../tutorials/advanced_features/">Advanced Features</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../noise_processes/">Noise Processes API</a></li><li class="is-active"><a class="tocitem" href>Noise Process Interface</a><ul class="internal"><li><a class="tocitem" href="#Step-Management"><span>Step Management</span></a></li><li><a class="tocitem" href="#Noise-Process-Types"><span>Noise Process Types</span></a></li><li><a class="tocitem" href="#Configuration"><span>Configuration</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li></ul></li></ul></li><li><span class="tocitem">Legacy Docs</span><ul><li><a class="tocitem" href="../../noise_processes/">Classic Noise Processes</a></li><li><a class="tocitem" href="../../abstract_noise_processes/">Abstract Noise Processes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Noise Process Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Noise Process Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqNoiseProcess.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/master/docs/src/api/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Noise-Process-Interface"><a class="docs-heading-anchor" href="#Noise-Process-Interface">Noise Process Interface</a><a id="Noise-Process-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-Process-Interface" title="Permalink"></a></h1><p>This page documents the interface functions for working with noise processes.</p><h2 id="Step-Management"><a class="docs-heading-anchor" href="#Step-Management">Step Management</a><a id="Step-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Step-Management" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.accept_step!"><a class="docstring-binding" href="#DiffEqNoiseProcess.accept_step!"><code>DiffEqNoiseProcess.accept_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accept_step!(W::NoiseProcess, dt, u, p, setup_next = true)</code></pre><p>Accept a noise step, updating the current time and noise values. This function is called by the SDE solvers after a successful integration step.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: The noise process</li><li><code>dt</code>: Time step size (may differ from W.dt due to adaptivity)</li><li><code>u</code>: Current solution value (for state-dependent noise)</li><li><code>p</code>: Parameters (for state-dependent noise)</li><li><code>setup_next</code>: Whether to prepare for the next step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/noise_interfaces/noise_process_interface.jl#L18-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.reject_step!"><a class="docstring-binding" href="#DiffEqNoiseProcess.reject_step!"><code>DiffEqNoiseProcess.reject_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reject_step!(W::NoiseProcess, dtnew, u, p)</code></pre><p>Handle rejection of a time step in adaptive algorithms.</p><p>When an adaptive SDE solver rejects a step, this function uses bridge interpolation to generate appropriate noise values for the smaller time step, maintaining distributional correctness.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: The noise process</li><li><code>dtnew</code>: New (smaller) time step after rejection</li><li><code>u</code>: Current solution value (for state-dependent noise)</li><li><code>p</code>: Parameters (for state-dependent noise)</li></ul><p><strong>Details</strong></p><p>The function implements different behaviors based on the RSWM algorithm:</p><ul><li>RSwM0: Uses bridging but discards future values (appropriate for tau-leaping)</li><li>RSwM1/2/3: Stores unused portions of noise in stacks for later use</li></ul><p>For tau-leaping with state-dependent rates, the rate λ is approximated as constant, so storing future values generated with the wrong rate doesn&#39;t make sense. RSwM0 discards the unused portion after bridging and recalculates fresh noise for subsequent steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/noise_interfaces/noise_process_interface.jl#L272-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.calculate_step!"><a class="docstring-binding" href="#DiffEqNoiseProcess.calculate_step!"><code>DiffEqNoiseProcess.calculate_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_step!(W::NoiseProcess, dt, u, p)</code></pre><p>Calculate noise increments for the given time step.</p><p>This function generates new random values for the noise process according to its distribution function.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: The noise process</li><li><code>dt</code>: Time step size</li><li><code>u</code>: Current solution value (for state-dependent noise)</li><li><code>p</code>: Parameters (for state-dependent noise)</li></ul><p><strong>Effects</strong></p><p>Updates W.dW (and W.dZ if auxiliary process exists) with new noise increments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/noise_interfaces/noise_process_interface.jl#L239-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.setup_next_step!"><a class="docstring-binding" href="#DiffEqNoiseProcess.setup_next_step!"><code>DiffEqNoiseProcess.setup_next_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setup_next_step!(W::NoiseProcess, u, p)</code></pre><p>Prepare the noise process for the next integration step.</p><p>This function manages the Rejection Sampling with Memory (RSWM) algorithm, handling the stacks of pre-computed noise values for adaptive time stepping.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: The noise process</li><li><code>u</code>: Current solution value (for state-dependent noise)</li><li><code>p</code>: Parameters (for state-dependent noise)</li></ul><p><strong>Details</strong></p><p>The function implements different variants of the RSWM algorithm:</p><ul><li>RSwM0: No memory - always recalculates (for state-dependent noise like compound Poisson)</li><li>RSwM1: Basic rejection sampling with single stack</li><li>RSwM2: Improved version with better memory management</li><li>RSwM3: Most advanced version with two-stack system (recommended for Brownian motion)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/noise_interfaces/noise_process_interface.jl#L63-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.save_noise!"><a class="docstring-binding" href="#DiffEqNoiseProcess.save_noise!"><code>DiffEqNoiseProcess.save_noise!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">save_noise!(W::NoiseProcess)</code></pre><p>Save the current noise value and time to the process history if it hasn&#39;t been saved already. This function is called automatically by the stepping algorithms to maintain the noise trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/noise_interfaces/noise_process_interface.jl#L1-L6">source</a></section></details></article><h2 id="Noise-Process-Types"><a class="docs-heading-anchor" href="#Noise-Process-Types">Noise Process Types</a><a id="Noise-Process-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-Process-Types" title="Permalink"></a></h2><h3 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h3><div class="admonition is-warning" id="Missing-docstring.-177c8bd0d3ea5316"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-177c8bd0d3ea5316" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>AbstractNoiseProcess</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h3><div class="admonition is-warning" id="Missing-docstring.-ba9d02e849da0f10"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-ba9d02e849da0f10" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>NoiseProcess</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-21987566fc2a4e59"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-21987566fc2a4e59" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SimpleNoiseProcess</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h2><h3 id="Rejection-Sampling-with-Memory-(RSWM)"><a class="docs-heading-anchor" href="#Rejection-Sampling-with-Memory-(RSWM)">Rejection Sampling with Memory (RSWM)</a><a id="Rejection-Sampling-with-Memory-(RSWM)-1"></a><a class="docs-heading-anchor-permalink" href="#Rejection-Sampling-with-Memory-(RSWM)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.RSWM"><a class="docstring-binding" href="#DiffEqNoiseProcess.RSWM"><code>DiffEqNoiseProcess.RSWM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RSWM(; discard_length = 1e-15, adaptivealg = :RSwM3)</code></pre><p>Rejection Sampling with Memory (RSWM) algorithm configuration for noise processes.</p><p>RSWM ensures distributional exactness when adaptive time stepping is used with noise processes. It maintains memory of rejected values to avoid biasing the noise distribution.</p><p><strong>Fields</strong></p><ul><li><code>discard_length</code>: Threshold for discarding stored values to save memory. Smaller values use more memory but are more accurate.</li><li><code>adaptivealg</code>: The adaptive algorithm variant to use (<code>:RSwM3</code> is recommended for Brownian motion)</li></ul><p><strong>Algorithm Variants</strong></p><ul><li><code>:RSwM1</code>: Basic rejection sampling with single stack</li><li><code>:RSwM2</code>: Improved version with better memory management</li><li><code>:RSwM3</code>: Most advanced version with two-stack system (recommended for Brownian motion)</li><li><code>:RSwM0</code>: No memory storage variant for state-dependent noise processes</li></ul><p><strong>About <code>:RSwM0</code> (No Memory)</strong></p><p>For tau-leaping with state-dependent rates, the rate λ is approximated as constant over each step. When a step is rejected and you use a Poisson bridge to pull back to a smaller dt, storing the &quot;future&quot; portion doesn&#39;t make sense because you don&#39;t know the correct λ anyway - it&#39;s always an approximation. Both storing and discarding have errors, but recalculating fresh is more appropriate for this use case.</p><p><code>:RSwM0</code> uses bridging/interpolation for rejected steps but discards future values instead of storing them. This is the appropriate choice for:</p><ul><li>Compound Poisson processes with state-dependent rates</li><li>Tau-leaping with post-leap adaptivity (Anderson&#39;s algorithm)</li></ul><p>Reference: Anderson, D.F. &quot;Incorporating postleap checks in tau-leaping&quot; J. Chem. Phys. 128, 054103 (2008); https://doi.org/10.1063/1.2819665</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Conservative (high accuracy) for Brownian motion
rswm_accurate = RSWM(discard_length = 1e-12)

# Aggressive (lower memory usage) for Brownian motion
rswm_fast = RSWM(discard_length = 1e-6)

# No memory for state-dependent Poisson processes
rswm_nomem = RSWM(adaptivealg = :RSwM0)

# Use in noise process
W = WienerProcess(0.0, 0.0, 1.0; rswm = rswm_accurate)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/rswm.jl#L1-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.adaptive_alg"><a class="docstring-binding" href="#DiffEqNoiseProcess.adaptive_alg"><code>DiffEqNoiseProcess.adaptive_alg</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">adaptive_alg(rswm::RSWM)</code></pre><p>Get the adaptive algorithm type from an RSWM configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/rswm.jl#L61-L65">source</a></section></details></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><p>These functions are used internally by the noise process implementations:</p><h3 id="Distribution-Functions"><a class="docs-heading-anchor" href="#Distribution-Functions">Distribution Functions</a><a id="Distribution-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Distribution-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.WHITE_NOISE_DIST"><a class="docstring-binding" href="#DiffEqNoiseProcess.WHITE_NOISE_DIST"><code>DiffEqNoiseProcess.WHITE_NOISE_DIST</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">WHITE_NOISE_DIST(dW, W, dt, u, p, t, rng)</code></pre><p>Generate white noise distributed according to N(0, dt) for use in Wiener processes.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>W</code>: Current noise value (unused for white noise)</li><li><code>dt</code>: Time step</li><li><code>u</code>: Current state (for state-dependent noise)</li><li><code>p</code>: Parameters</li><li><code>t</code>: Current time</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Random values distributed as N(0, dt), scaled by √dt</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L136-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.WHITE_NOISE_BRIDGE"><a class="docstring-binding" href="#DiffEqNoiseProcess.WHITE_NOISE_BRIDGE"><code>DiffEqNoiseProcess.WHITE_NOISE_BRIDGE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">WHITE_NOISE_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate white noise for Brownian bridge interpolation between two points.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>W</code>: Current noise value</li><li><code>W0</code>: Starting noise value</li><li><code>Wh</code>: Target noise value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Interpolated noise value that maintains correct distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L161-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.VBT_BRIDGE"><a class="docstring-binding" href="#DiffEqNoiseProcess.VBT_BRIDGE"><code>DiffEqNoiseProcess.VBT_BRIDGE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">VBT_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate noise for Virtual Brownian Tree (VBT) bridge interpolation.</p><p>The VBT bridge is a memory-efficient method for generating Brownian paths that can be evaluated at arbitrary time points without storing the entire path.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>W</code>: Current noise value</li><li><code>W0</code>: Starting noise value</li><li><code>Wh</code>: Target noise value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Interpolated noise value using the VBT bridge formula</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L187-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST"><a class="docstring-binding" href="#DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST"><code>DiffEqNoiseProcess.INPLACE_WHITE_NOISE_DIST</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">INPLACE_WHITE_NOISE_DIST(rand_vec, W, dt, u, p, t, rng)</code></pre><p>Generate white noise distributed according to N(0, dt) in-place.</p><p>This is the in-place version of WHITE<em>NOISE</em>DIST, modifying the provided array rather than allocating a new one.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with noise values</li><li><code>W</code>: Current noise value (unused for white noise)</li><li><code>dt</code>: Time step</li><li><code>u</code>: Current state (for state-dependent noise)</li><li><code>p</code>: Parameters</li><li><code>t</code>: Current time</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain random values distributed as N(0, dt)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L248-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE"><a class="docstring-binding" href="#DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE"><code>DiffEqNoiseProcess.INPLACE_WHITE_NOISE_BRIDGE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">INPLACE_WHITE_NOISE_BRIDGE(rand_vec, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate white noise for Brownian bridge interpolation in-place.</p><p>This is the in-place version of WHITE<em>NOISE</em>BRIDGE, modifying the provided array rather than allocating a new one.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with interpolated noise values</li><li><code>W</code>: Current noise value</li><li><code>W0</code>: Starting noise value</li><li><code>Wh</code>: Target noise value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain interpolated noise values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L273-L293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.INPLACE_VBT_BRIDGE"><a class="docstring-binding" href="#DiffEqNoiseProcess.INPLACE_VBT_BRIDGE"><code>DiffEqNoiseProcess.INPLACE_VBT_BRIDGE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">INPLACE_VBT_BRIDGE(rand_vec, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate noise for Virtual Brownian Tree (VBT) bridge interpolation in-place.</p><p>This is the in-place version of VBT_BRIDGE, modifying the provided array rather than allocating a new one.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with interpolated noise values</li><li><code>W</code>: Current noise value</li><li><code>W0</code>: Starting noise value</li><li><code>Wh</code>: Target noise value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain VBT-interpolated noise values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L301-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.REAL_WHITE_NOISE_DIST"><a class="docstring-binding" href="#DiffEqNoiseProcess.REAL_WHITE_NOISE_DIST"><code>DiffEqNoiseProcess.REAL_WHITE_NOISE_DIST</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">REAL_WHITE_NOISE_DIST(dW, W, dt, u, p, t, rng)</code></pre><p>Generate real-valued white noise distributed according to N(0, dt).</p><p>Unlike WHITE<em>NOISE</em>DIST, this function always generates real-valued noise, even if the input type would normally support complex values.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>W</code>: Current noise value (unused for white noise)</li><li><code>dt</code>: Time step</li><li><code>u</code>: Current state (for state-dependent noise)</li><li><code>p</code>: Parameters</li><li><code>t</code>: Current time</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Real-valued random numbers distributed as N(0, dt), scaled by √dt</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L367-L386">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.REAL_WHITE_NOISE_BRIDGE"><a class="docstring-binding" href="#DiffEqNoiseProcess.REAL_WHITE_NOISE_BRIDGE"><code>DiffEqNoiseProcess.REAL_WHITE_NOISE_BRIDGE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">REAL_WHITE_NOISE_BRIDGE(dW, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate real-valued white noise for Brownian bridge interpolation.</p><p>This function ensures the generated noise is always real-valued, even for complex-valued endpoints.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>W</code>: Current noise value</li><li><code>W0</code>: Starting noise value</li><li><code>Wh</code>: Target noise value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Real-valued interpolated noise value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L394-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_DIST"><a class="docstring-binding" href="#DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_DIST"><code>DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_DIST</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">REAL_INPLACE_WHITE_NOISE_DIST(rand_vec, W, dt, u, p, t, rng)</code></pre><p>Generate real-valued white noise distributed according to N(0, dt) in-place.</p><p>This is the in-place version of REAL<em>WHITE</em>NOISE_DIST.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with noise values</li><li><code>W</code>: Current noise value (unused for white noise)</li><li><code>dt</code>: Time step</li><li><code>u</code>: Current state (for state-dependent noise)</li><li><code>p</code>: Parameters</li><li><code>t</code>: Current time</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain real-valued random numbers distributed as N(0, dt)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L442-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_BRIDGE"><a class="docstring-binding" href="#DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_BRIDGE"><code>DiffEqNoiseProcess.REAL_INPLACE_WHITE_NOISE_BRIDGE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">REAL_INPLACE_WHITE_NOISE_BRIDGE(rand_vec, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate real-valued white noise for Brownian bridge interpolation in-place.</p><p>This is the in-place version of REAL<em>WHITE</em>NOISE_BRIDGE.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with interpolated noise values</li><li><code>W</code>: Current noise value</li><li><code>W0</code>: Starting noise value</li><li><code>Wh</code>: Target noise value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain real-valued interpolated noise values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L466-L485">source</a></section></details></article><h3 id="Random-Number-Generation"><a class="docs-heading-anchor" href="#Random-Number-Generation">Random Number Generation</a><a id="Random-Number-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Number-Generation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.wiener_randn"><a class="docstring-binding" href="#DiffEqNoiseProcess.wiener_randn"><code>DiffEqNoiseProcess.wiener_randn</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wiener_randn(rng::AbstractRNG, ::Type{T}) where {T}</code></pre><p>Generate a random number from the standard normal distribution for type T.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>T</code>: Type of the random number to generate</li></ul><p><strong>Returns</strong></p><p>A random number of type T from the standard normal distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L2-L13">source</a></section><section><div><pre><code class="language-julia hljs">wiener_randn(rng::AbstractRNG, proto::AbstractArray{T}) where {T &lt;: Number}</code></pre><p>Generate an array of random numbers from the standard normal distribution, matching the size of the prototype array.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>proto</code>: Prototype array whose size determines the output size</li></ul><p><strong>Returns</strong></p><p>An array of random numbers from the standard normal distribution with the same size as proto</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L16-L27">source</a></section><section><div><pre><code class="language-julia hljs">wiener_randn(rng::AbstractRNG, proto::T) where {T &lt;: StaticArraysCore.SArray}</code></pre><p>Generate a static array of random numbers from the standard normal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>proto</code>: Prototype static array</li></ul><p><strong>Returns</strong></p><p>A static array of the same type as proto filled with standard normal random numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L31-L42">source</a></section><section><div><pre><code class="language-julia hljs">wiener_randn(rng::AbstractRNG, proto)</code></pre><p>Generate random numbers from the standard normal distribution for arbitrary types.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>proto</code>: Prototype object whose type and size determine the output</li></ul><p><strong>Returns</strong></p><p>Random values converted to the same type as proto</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L49-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.wiener_randn!"><a class="docstring-binding" href="#DiffEqNoiseProcess.wiener_randn!"><code>DiffEqNoiseProcess.wiener_randn!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wiener_randn!(rng::AbstractRNG, rand_vec::AbstractArray)</code></pre><p>Fill an array with random numbers from the standard normal distribution in-place.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>rand_vec</code>: Array to fill with random values</li></ul><p><strong>Returns</strong></p><p>The modified rand_vec filled with standard normal random numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L64-L75">source</a></section><section><div><pre><code class="language-julia hljs">wiener_randn!(rng::AbstractRNG, rand_vec)</code></pre><p>Fill an arbitrary container with random numbers from the standard normal distribution in-place using broadcasting.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (not used in this fallback)</li><li><code>rand_vec</code>: Container to fill with random values</li></ul><p><strong>Returns</strong></p><p>The modified rand_vec filled with standard normal random numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L77-L88">source</a></section><section><div><pre><code class="language-julia hljs">wiener_randn!(rng::AbstractRNG, rand_vec::GPUArraysCore.AbstractGPUArray)</code></pre><p>Fill a GPU array with random numbers from the standard normal distribution in-place.</p><p>This specialized method works for GPUs because it doesn&#39;t pass the RNG to the GPU kernel, which may not be supported on all GPU backends.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (not passed to GPU)</li><li><code>rand_vec</code>: GPU array to fill with random values</li></ul><p><strong>Returns</strong></p><p>The modified rand_vec filled with standard normal random numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L93-L107">source</a></section><section><div><pre><code class="language-julia hljs">wiener_randn!(y::AbstractRNG, x::AbstractArray{&lt;:Complex{T}}) where {T &lt;: Number}</code></pre><p>Fill an array of complex numbers with random values from the standard complex normal distribution in-place.</p><p>Each complex number is generated as (a + bi)/√2 where a and b are independent standard normal random variables.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Random number generator</li><li><code>x</code>: Array of complex numbers to fill</li></ul><p><strong>Returns</strong></p><p>The modified array filled with complex normal random numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/wiener.jl#L112-L125">source</a></section></details></article><h3 id="Ornstein-Uhlenbeck-Specific"><a class="docs-heading-anchor" href="#Ornstein-Uhlenbeck-Specific">Ornstein-Uhlenbeck Specific</a><a id="Ornstein-Uhlenbeck-Specific-1"></a><a class="docs-heading-anchor-permalink" href="#Ornstein-Uhlenbeck-Specific" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.OrnsteinUhlenbeck"><a class="docstring-binding" href="#DiffEqNoiseProcess.OrnsteinUhlenbeck"><code>DiffEqNoiseProcess.OrnsteinUhlenbeck</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OrnsteinUhlenbeck{T1, T2, T3}</code></pre><p>Parameters for the Ornstein-Uhlenbeck process.</p><p><strong>Fields</strong></p><ul><li><code>Θ</code>: Mean reversion rate (higher values mean faster reversion)</li><li><code>μ</code>: Long-term mean (the value the process reverts to)</li><li><code>σ</code>: Volatility/diffusion coefficient</li></ul><p>The process follows the SDE: dX<em>t = Θ(μ - X</em>t)dt + σ dW_t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/ornstein_uhlenbeck.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.OrnsteinUhlenbeck!"><a class="docstring-binding" href="#DiffEqNoiseProcess.OrnsteinUhlenbeck!"><code>DiffEqNoiseProcess.OrnsteinUhlenbeck!</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OrnsteinUhlenbeck!{T1, T2, T3}</code></pre><p>In-place version of OrnsteinUhlenbeck parameters.</p><p><strong>Fields</strong></p><ul><li><code>Θ</code>: Mean reversion rate (higher values mean faster reversion)</li><li><code>μ</code>: Long-term mean (the value the process reverts to)</li><li><code>σ</code>: Volatility/diffusion coefficient</li></ul><p>The process follows the SDE: dX<em>t = Θ(μ - X</em>t)dt + σ dW_t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/ornstein_uhlenbeck.jl#L177-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.ou_bridge"><a class="docstring-binding" href="#DiffEqNoiseProcess.ou_bridge"><code>DiffEqNoiseProcess.ou_bridge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ou_bridge(dW, ou, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate Ornstein-Uhlenbeck bridge interpolation between two points.</p><p>Provides exact sampling from an OU process conditioned on both endpoints, useful for adaptive time-stepping and interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>ou</code>: OrnsteinUhlenbeck parameters</li><li><code>W</code>: Current noise process state</li><li><code>W0</code>: Starting value</li><li><code>Wh</code>: Target value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Interpolated OU process value that maintains the correct distribution</p><p><strong>References</strong></p><ul><li>http://www.tandfonline.com/doi/pdf/10.1080/14697688.2014.941913</li><li>https://arxiv.org/pdf/1011.0067.pdf (page 18)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/ornstein_uhlenbeck.jl#L62-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.ou_bridge!"><a class="docstring-binding" href="#DiffEqNoiseProcess.ou_bridge!"><code>DiffEqNoiseProcess.ou_bridge!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ou_bridge!(rand_vec, ou, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate Ornstein-Uhlenbeck bridge interpolation in-place.</p><p>This is the in-place version of <code>ou_bridge</code>, modifying the provided array rather than allocating a new one.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with interpolated values</li><li><code>ou</code>: OrnsteinUhlenbeck parameters</li><li><code>W</code>: Current noise process state</li><li><code>W0</code>: Starting value</li><li><code>Wh</code>: Target value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain the interpolated OU process values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/ornstein_uhlenbeck.jl#L105-L126">source</a></section></details></article><h3 id="Geometric-Brownian-Motion-Specific"><a class="docs-heading-anchor" href="#Geometric-Brownian-Motion-Specific">Geometric Brownian Motion Specific</a><a id="Geometric-Brownian-Motion-Specific-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Brownian-Motion-Specific" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.GeometricBrownianMotion"><a class="docstring-binding" href="#DiffEqNoiseProcess.GeometricBrownianMotion"><code>DiffEqNoiseProcess.GeometricBrownianMotion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeometricBrownianMotion{T1, T2}</code></pre><p>Parameters for the geometric Brownian motion process.</p><p><strong>Fields</strong></p><ul><li><code>μ</code>: Drift parameter (expected return rate)</li><li><code>σ</code>: Volatility parameter (standard deviation of returns)</li></ul><p>The process follows the SDE: dX<em>t = μX</em>t dt + σX<em>t dW</em>t</p><p>This is commonly used in financial models, particularly the Black-Scholes model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/geometric_bm.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.GeometricBrownianMotion!"><a class="docstring-binding" href="#DiffEqNoiseProcess.GeometricBrownianMotion!"><code>DiffEqNoiseProcess.GeometricBrownianMotion!</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeometricBrownianMotion!{T1, T2}</code></pre><p>In-place version of GeometricBrownianMotion parameters.</p><p><strong>Fields</strong></p><ul><li><code>μ</code>: Drift parameter (expected return rate)</li><li><code>σ</code>: Volatility parameter (standard deviation of returns)</li></ul><p>The process follows the SDE: dX<em>t = μX</em>t dt + σX<em>t dW</em>t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/geometric_bm.jl#L161-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.gbm_bridge"><a class="docstring-binding" href="#DiffEqNoiseProcess.gbm_bridge"><code>DiffEqNoiseProcess.gbm_bridge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gbm_bridge(dW, gbm, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate geometric Brownian motion bridge interpolation between two points.</p><p>Provides exact sampling from a GBM process conditioned on both endpoints, useful for adaptive time-stepping and interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>gbm</code>: GeometricBrownianMotion parameters</li><li><code>W</code>: Current noise process state</li><li><code>W0</code>: Starting value</li><li><code>Wh</code>: Target value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Interpolated GBM process value that maintains the correct log-normal distribution</p><p><strong>Reference</strong></p><p>https://math.stackexchange.com/questions/412470/conditional-distribution-in-brownian-motion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/geometric_bm.jl#L59-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.gbm_bridge!"><a class="docstring-binding" href="#DiffEqNoiseProcess.gbm_bridge!"><code>DiffEqNoiseProcess.gbm_bridge!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gbm_bridge!(rand_vec, gbm, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate geometric Brownian motion bridge interpolation in-place.</p><p>This is the in-place version of <code>gbm_bridge</code>, modifying the provided array rather than allocating a new one.</p><p><strong>Arguments</strong></p><ul><li><code>rand_vec</code>: Array to fill with interpolated values</li><li><code>gbm</code>: GeometricBrownianMotion parameters</li><li><code>W</code>: Current noise process state</li><li><code>W0</code>: Starting value</li><li><code>Wh</code>: Target value at end of interval</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Effects</strong></p><p>Modifies rand_vec to contain the interpolated GBM process values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/geometric_bm.jl#L99-L120">source</a></section></details></article><h3 id="Compound-Poisson-Specific"><a class="docs-heading-anchor" href="#Compound-Poisson-Specific">Compound Poisson Specific</a><a id="Compound-Poisson-Specific-1"></a><a class="docs-heading-anchor-permalink" href="#Compound-Poisson-Specific" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.CompoundPoissonProcess"><a class="docstring-binding" href="#DiffEqNoiseProcess.CompoundPoissonProcess"><code>DiffEqNoiseProcess.CompoundPoissonProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompoundPoissonProcess{R, CR}</code></pre><p>A compound Poisson process for modeling jump processes.</p><p>The process has jumps that occur according to a Poisson process with given rate, and jump sizes determined by a specified distribution.</p><p><strong>Fields</strong></p><ul><li><code>rate</code>: Jump rate function or constant (λ parameter)</li><li><code>currate</code>: Current rate value (cached for efficiency)</li><li><code>computerates</code>: Whether to recompute rates at each step</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CompoundPoissonProcess(rate, t0, W0; computerates = true, rswm = RSWM(adaptivealg = :RSwM0), kwargs...)</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>computerates</code>: If <code>true</code>, recompute rates at each step (for state-dependent rates)</li><li><code>rswm</code>: RSWM algorithm configuration. Defaults to <code>:RSwM0</code> (no memory) which is appropriate for state-dependent rates. Use <code>RSWM(adaptivealg = :RSwM3)</code> for constant-rate processes if memory reuse is desired.</li></ul><p><strong>Why <code>:RSwM0</code> is the Default</strong></p><p>For tau-leaping with state-dependent rates, the rate λ is approximated as constant over each step. When a step is rejected, storing the &quot;future&quot; portion doesn&#39;t make sense because you don&#39;t know the correct λ anyway - it&#39;s always an approximation. Recalculating fresh is more appropriate for this use case than reusing values generated with the wrong rate.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Constant rate
proc = CompoundPoissonProcess(2.0, 0.0, 0.0)

# State-dependent rate (default RSwM0 is appropriate)
rate_func(u, p, t) = 1.0 + 0.5*sin(t)
proc = CompoundPoissonProcess(rate_func, 0.0, 0.0)

# Constant rate with memory reuse (optional optimization)
proc = CompoundPoissonProcess(2.0, 0.0, 0.0; rswm = RSWM(adaptivealg = :RSwM3))</code></pre><p><strong>References</strong></p><p>https://www.math.wisc.edu/~anderson/papers/AndPostleap.pdf Incorporating postleap checks in tau-leaping J. Chem. Phys. 128, 054103 (2008); https://doi.org/10.1063/1.2819665</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/compoundpoisson.jl#L37-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.CompoundPoissonProcess!"><a class="docstring-binding" href="#DiffEqNoiseProcess.CompoundPoissonProcess!"><code>DiffEqNoiseProcess.CompoundPoissonProcess!</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompoundPoissonProcess!{R, CR}</code></pre><p>In-place version of CompoundPoissonProcess.</p><p>See <code>CompoundPoissonProcess</code> for details.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CompoundPoissonProcess!(rate, t0, W0; computerates = true, rswm = RSWM(adaptivealg = :RSwM0), kwargs...)</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>computerates</code>: If <code>true</code>, recompute rates at each step (for state-dependent rates)</li><li><code>rswm</code>: RSWM algorithm configuration. Defaults to <code>:RSwM0</code> (no memory) which is appropriate for state-dependent rates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/compoundpoisson.jl#L133-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.cpp_bridge"><a class="docstring-binding" href="#DiffEqNoiseProcess.cpp_bridge"><code>DiffEqNoiseProcess.cpp_bridge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cpp_bridge(dW, cpp, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>Generate compound Poisson process bridge interpolation between two points.</p><p>Uses binomial thinning to distribute jumps appropriately between endpoints.</p><p><strong>Arguments</strong></p><ul><li><code>dW</code>: Noise increment container</li><li><code>cpp</code>: CompoundPoissonProcess parameters</li><li><code>W</code>: Current noise process state</li><li><code>W0</code>: Starting value</li><li><code>Wh</code>: Jump count difference (must be integer)</li><li><code>q</code>: Interpolation parameter (0 to 1)</li><li><code>h</code>: Total time interval</li><li><code>u</code>, <code>p</code>, <code>t</code>: State, parameters, and time (for compatibility)</li><li><code>rng</code>: Random number generator</li></ul><p><strong>Returns</strong></p><p>Number of jumps distributed according to binomial thinning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/compoundpoisson.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqNoiseProcess.cpp_bridge!"><a class="docstring-binding" href="#DiffEqNoiseProcess.cpp_bridge!"><code>DiffEqNoiseProcess.cpp_bridge!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cpp_bridge!(rand_vec, cpp, W, W0, Wh, q, h, u, p, t, rng)</code></pre><p>In-place version of <code>cpp_bridge</code>.</p><p><strong>Effects</strong></p><p>Modifies rand_vec to contain binomially distributed jump counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/1fe149963114a9fbdc513a14dcfc4fee54a3b229/src/compoundpoisson.jl#L25-L32">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noise_processes/">« Noise Processes API</a><a class="docs-footer-nextpage" href="../../noise_processes/">Classic Noise Processes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 15:55">Tuesday 13 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
