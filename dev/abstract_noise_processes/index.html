<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Abstract Noise Processes · DiffEqNoiseProcess.jl</title><meta name="title" content="Abstract Noise Processes · DiffEqNoiseProcess.jl"/><meta property="og:title" content="Abstract Noise Processes · DiffEqNoiseProcess.jl"/><meta property="twitter:title" content="Abstract Noise Processes · DiffEqNoiseProcess.jl"/><meta name="description" content="Documentation for DiffEqNoiseProcess.jl."/><meta property="og:description" content="Documentation for DiffEqNoiseProcess.jl."/><meta property="twitter:description" content="Documentation for DiffEqNoiseProcess.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqNoiseProcess/stable/abstract_noise_processes/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqNoiseProcess/stable/abstract_noise_processes/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqNoiseProcess/stable/abstract_noise_processes/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DiffEqNoiseProcess.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffEqNoiseProcess.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../noise_processes/">Classic Noise Processes</a></li><li class="is-active"><a class="tocitem" href>Abstract Noise Processes</a><ul class="internal"><li><a class="tocitem" href="#The-Standard-AbstractNoiseProcess"><span>The Standard <code>AbstractNoiseProcess</code></span></a></li><li><a class="tocitem" href="#Alternative-AbstractNoiseProcess-Types"><span>Alternative <code>AbstractNoiseProcess</code> Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Abstract Noise Processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Abstract Noise Processes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqNoiseProcess.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/master/docs/src/abstract_noise_processes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Abstract-Noise-Processes"><a class="docs-heading-anchor" href="#Abstract-Noise-Processes">Abstract Noise Processes</a><a id="Abstract-Noise-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Noise-Processes" title="Permalink"></a></h1><p>In addition to the <code>NoiseProcess</code> type, more general <code>AbstractNoiseProcess</code>es are defined. The <code>NoiseGrid</code> allows you to define a noise process from a set of pre-calculated points (the &quot;normal&quot; way). The <code>NoiseApproximation</code> allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations.</p><p>The <code>NoiseWrapper</code> allows one to wrap a <code>NoiseProcess</code> from a previous simulation to reuse it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example by solving with a smaller <code>dt</code>) in a distributionally-exact manner. It is demonstrated how the <code>NoiseWrapper</code> can be used to wrap the <code>NoiseProcess</code> of one SDE/RODE solution to reuse the same noise process in another simulation.</p><p>The <code>VirtualBrownianTree</code> allows one to trade speed for O(1) memory usage. Instead of storing Brownian motion increments, the <code>VirtualBrownianTree</code> samples recursively from the midpoint <code>tmid</code> of Brownian bridges, using a splittable PRNG. The recursion terminates when the query time agrees within some tolerance with <code>tmid</code> or when the maximum depth of the tree is reached.</p><p>Lastly, the <code>NoiseFunction</code> allows you to use any function of time as the noise process, while <code>NoiseTransport</code> lets you define a random process as the transport of a random variable or a random vector by a time-dependent function. Together, these functionalities allow you to define any colored noise process and use it efficiently and accurately in your simulations.</p><h2 id="The-Standard-AbstractNoiseProcess"><a class="docs-heading-anchor" href="#The-Standard-AbstractNoiseProcess">The Standard <code>AbstractNoiseProcess</code></a><a id="The-Standard-AbstractNoiseProcess-1"></a><a class="docs-heading-anchor-permalink" href="#The-Standard-AbstractNoiseProcess" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseProcess" href="#DiffEqNoiseProcess.NoiseProcess"><code>DiffEqNoiseProcess.NoiseProcess</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoiseProcess{T, N, Tt, T2, T3, ZType, F, F2, inplace, S1, S2, RSWM, C, RNGType} &lt;:
{T, N, Vector{T2}, inplace}</code></pre><p>A <code>NoiseProcess</code> is a type defined as:</p><pre><code class="language-julia hljs">NoiseProcess(t0, W0, Z0, dist, bridge;
    iip = SciMLBase.isinplace(dist, 3),
    rswm = RSWM(), save_everystep = true,
    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
    reset = true, reseed = true)</code></pre><ul><li><code>t0</code> is the first timepoint</li><li><code>W0</code> is the first value of the process.</li><li><code>Z0</code> is the first value of the pseudo-process. This is necessary for higher order algorithms. If it&#39;s not needed, set to <code>nothing</code>.</li><li><code>dist</code> the distribution of the steps over time.</li><li><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</li><li><code>covariance</code> is the covariance matrix of the noise process. If not provided, the noise is assumed to be uncorrelated in each variable.</li><li><code>save_everystep</code> whether to save every step of the Brownian timeseries.</li><li><code>rng</code> the local RNG used for generating the random numbers.</li><li><code>reset</code> whether to reset the process with each solve.</li><li><code>reseed</code> whether to reseed the process with each solve.</li></ul><p>The signature for the <code>dist</code> is</p><pre><code class="language-julia hljs">dist!(rand_vec, W, dt, rng)</code></pre><p>for inplace functions, and</p><pre><code class="language-julia hljs">rand_vec = dist(W, dt, rng)</code></pre><p>otherwise. The signature for <code>bridge</code> is</p><pre><code class="language-julia hljs">bridge!(rand_vec, W, W0, Wh, q, h, rng)</code></pre><p>and the out of place syntax is</p><pre><code class="language-julia hljs">rand_vec = bridge!(W, W0, Wh, q, h, rng)</code></pre><p>Here, <code>W</code> is the noise process, <code>W0</code> is the left side of the current interval, <code>Wh</code> is the right side of the current interval, <code>h</code> is the interval length, and <code>q</code> is the proportion from the left where the interpolation is occurring.</p><p><strong>Direct Construction Example</strong></p><p>The easiest way to show how to directly construct a <code>NoiseProcess</code> is by example. Here we will show how to directly construct a <code>NoiseProcess</code> which generates Gaussian white noise.</p><p>This is the noise process, that uses <code>randn!</code>. A special dispatch is added for complex numbers for <code>(randn()+im*randn())/sqrt(2)</code>. This function is <code>DiffEqNoiseProcess.wiener_randn</code> (or with <code>!</code> respectively).</p><p>The first function that must be defined is the noise distribution. This is how to generate <span>$W(t+dt)$</span> given that we know <span>$W(x)$</span> for <span>$x∈[t₀,t]$</span>. For Gaussian white noise, we know that</p><p class="math-container">\[W(dt) ∼ N(0,dt)\]</p><p>for <span>$W(0)=0$</span> which defines the stepping distribution. Thus, its noise distribution function is:</p><pre><code class="language-julia hljs">@inline function WHITE_NOISE_DIST(W, dt, rng)
    if W.dW isa AbstractArray &amp;&amp; !(W.dW isa SArray)
        return @fastmath sqrt(abs(dt)) * wiener_randn(rng, W.dW)
    else
        return @fastmath sqrt(abs(dt)) * wiener_randn(rng, typeof(W.dW))
    end
end</code></pre><p>for the out of place versions, and for the inplace versions</p><pre><code class="language-julia hljs">function INPLACE_WHITE_NOISE_DIST(rand_vec, W, dt, rng)
    wiener_randn!(rng, rand_vec)
    sqrtabsdt = @fastmath sqrt(abs(dt))
    @. rand_vec *= sqrtabsdt
end</code></pre><p>Optionally, we can provide a bridging distribution. This is the distribution of <span>$W(qh)$</span> for <span>$q∈[0,1]$</span> given that we know <span>$W(0)=0$</span> and <span>$W(h)=Wₕ$</span>. For Brownian motion, this is known as the Brownian Bridge, and is well known to have the distribution:</p><p class="math-container">\[W(qh) ∼ N(qWₕ,(1-q)qh)\]</p><p>Thus, we have the out-of-place and in-place versions as:</p><pre><code class="language-julia hljs">function WHITE_NOISE_BRIDGE(W, W0, Wh, q, h, rng)
    if W.dW isa AbstractArray
        return @fastmath sqrt((1 - q) * q * abs(h)) * wiener_randn(rng, W.dW) + q * Wh
    else
        return @fastmath sqrt((1 - q) * q * abs(h)) * wiener_randn(rng, typeof(W.dW)) +
                         q * Wh
    end
end
function INPLACE_WHITE_NOISE_BRIDGE(rand_vec, W, W0, Wh, q, h, rng)
    wiener_randn!(rng, rand_vec)
    #rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*Wh
    sqrtcoeff = @fastmath sqrt((1 - q) * q * abs(h))
    @. rand_vec = sqrtcoeff * rand_vec + q * Wh
end</code></pre><p>These functions are then placed in a noise process:</p><pre><code class="language-julia hljs">NoiseProcess(t0, W0, Z0, WHITE_NOISE_DIST, WHITE_NOISE_BRIDGE; kwargs)
NoiseProcess(t0, W0, Z0, INPLACE_WHITE_NOISE_DIST, INPLACE_WHITE_NOISE_BRIDGE; kwargs)</code></pre><p>Notice that we can optionally provide an alternative adaptive algorithm for the timestepping rejections. <code>RSWM()</code> defaults to the Rejection Sampling with Memory 3 algorithm (RSwM3).</p><p>Note that the standard constructors are simply:</p><pre><code class="language-julia hljs">function WienerProcess(t0, W0, Z0 = nothing)
    NoiseProcess(t0, W0, Z0, WHITE_NOISE_DIST, WHITE_NOISE_BRIDGE; kwargs)
end
function WienerProcess!(t0, W0, Z0 = nothing)
    NoiseProcess(t0, W0, Z0, INPLACE_WHITE_NOISE_DIST, INPLACE_WHITE_NOISE_BRIDGE; kwargs)
end</code></pre><p>These will generate a Wiener process, which can be stepped with <code>step!(W,dt)</code>, and interpolated as <code>W(t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L3-L153">source</a></section></article><h2 id="Alternative-AbstractNoiseProcess-Types"><a class="docs-heading-anchor" href="#Alternative-AbstractNoiseProcess-Types">Alternative <code>AbstractNoiseProcess</code> Types</a><a id="Alternative-AbstractNoiseProcess-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-AbstractNoiseProcess-Types" title="Permalink"></a></h2><p>In addition to the mathematically-defined noise processes above, there exists more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseWrapper" href="#DiffEqNoiseProcess.NoiseWrapper"><code>DiffEqNoiseProcess.NoiseWrapper</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoiseWrapper{T, N, Tt, T2, T3, T4, ZType, inplace} &lt;:
AbstractNoiseProcess{T, N, Vector{T2}, inplace}</code></pre><p>This produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to reuse a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NoiseWrapper(source::AbstractNoiseProcess{T, N, Vector{T2}, inplace};
    reset = true, reverse = false, indx = nothing) where {T, N, T2, inplace}</code></pre><p><strong>NoiseWrapper Example</strong></p><p>In this example, we will solve an SDE three times:</p><ul><li>First, to generate a noise process</li><li>Second, with the same timesteps to show the values are the same</li><li>Third, with half-sized timesteps</li></ul><p>First, we will generate a noise process by solving an SDE:</p><pre><code class="language-julia hljs">using StochasticDiffEq, DiffEqNoiseProcess
f1(u, p, t) = 1.01u
g1(u, p, t) = 1.01u
dt = 1 // 2^(4)
prob1 = SDEProblem(f1, g1, 1.0, (0.0, 1.0))
sol1 = solve(prob1, EM(), dt = dt, save_noise = true)</code></pre><p>Now we wrap the noise into a NoiseWrapper and solve the same problem:</p><pre><code class="language-julia hljs">W2 = NoiseWrapper(sol1.W)
prob1 = SDEProblem(f1, g1, 1.0, (0.0, 1.0), noise = W2)
sol2 = solve(prob1, EM(), dt = dt)</code></pre><p>We can test</p><pre><code class="language-julia hljs">@test sol1.u ≈ sol2.u</code></pre><p>to see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller <code>dt</code>:</p><pre><code class="language-julia hljs">W3 = NoiseWrapper(sol1.W)
prob2 = SDEProblem(f1, g1, 1.0, (0.0, 1.0), noise = W3)

dt = 1 // 2^(5)
sol3 = solve(prob2, EM(), dt = dt)</code></pre><p>We can plot the results to see what this looks like:</p><pre><code class="language-julia hljs">using Plots
plot(sol1)
plot!(sol2)
plot!(sol3)</code></pre><p><img src="../assets/noise_process.png" alt="noise_process"/></p><p>In this plot, <code>sol2</code> covers up <code>sol1</code> because they hit essentially the same values. You can see that <code>sol3</code> is similar to the others, because it&#39;s using the same underlying noise process, just sampled much finer.</p><p>To double-check, we see that:</p><pre><code class="language-julia hljs">plot(sol1.W)
plot!(sol2.W)
plot!(sol3.W)</code></pre><p><img src="../assets/coupled_wiener.png" alt="coupled_wiener"/></p><p>the coupled Wiener processes coincide at every other time point, and the intermediate timepoints were calculated according to a Brownian bridge.</p><p><strong>Adaptive NoiseWrapper Example</strong></p><p>Here we will show that the same noise can be used with the adaptive methods using the <code>NoiseWrapper</code>. <code>SRI</code> and <code>SRIW1</code> use slightly different error estimators, and thus have slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:</p><pre><code class="language-julia hljs">prob = SDEProblem(f1, g1, ones(2), (0.0, 1.0))
sol4 = solve(prob, SRI(), abstol = 1e-8, save_noise = true)

W2 = NoiseWrapper(sol4.W)
prob2 = SDEProblem(f1, g1, ones(2), (0.0, 1.0), noise = W2)
sol5 = solve(prob2, SRIW1(), abstol = 1e-8)

using Plots
plot(sol4)
plot!(sol5)</code></pre><p><img src="../assets/SRI_SRIW1_diff.png" alt="SRI_SRIW1_diff"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L410-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseFunction" href="#DiffEqNoiseProcess.NoiseFunction"><code>DiffEqNoiseProcess.NoiseFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoiseFunction{T, N, wType, zType, Tt, T2, T3, inplace} &lt;:
AbstractNoiseProcess{T, N, nothing, inplace}</code></pre><p>This allows you to use any arbitrary function <code>W(t)</code> as a <code>NoiseProcess</code>. This will use the function lazily, only caching values required to minimize function calls, but not storing the entire noise array. This requires an initial time point <code>t0</code> in the domain of <code>W</code>. A second function is needed if the desired SDE algorithm requires multiple processes.</p><pre><code class="language-julia hljs">NoiseFunction{iip}(t0, W, Z = nothing;
    noise_prototype = W(nothing, nothing, t0),
    reset = true) where {iip}</code></pre><p>Additionally, one can use an in-place function <code>W(out1,out2,t)</code> for more efficient generation of the arrays for mulitidimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the <code>noise_prototype</code> needs to be set.</p><p><strong>NoiseFunction Example</strong></p><p>The <code>NoiseFunction</code> is pretty simple: pass a function. As a silly example, we can use <code>exp</code> as a noise process by doing:</p><pre><code class="language-julia hljs">f(u, p, t) = exp(t)
W = NoiseFunction(0.0, f)</code></pre><p>If it&#39;s mulitidimensional and an in-place function is used, the <code>noise_prototype</code> must be given. For example:</p><pre><code class="language-julia hljs">f(out, u, p, t) = (out .= exp(t))
W = NoiseFunction(0.0, f, noise_prototype = rand(4))</code></pre><p>This allows you to put arbitrarily weird noise into SDEs and RODEs. Have fun.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L577-L619">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseTransport" href="#DiffEqNoiseProcess.NoiseTransport"><code>DiffEqNoiseProcess.NoiseTransport</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoiseTransport{T, N, wType, zType, Tt, T2, T3, TRV, Trv, RNGType, inplace} &lt;:
AbstractNoiseProcess{T, N, nothing, inplace}</code></pre><p>This allows you to define stochastic processes of the form <code>W(t) = f(u, p, t, RV)</code>, where <code>f</code> is a function and <code>RV</code> represents a random variable. This will use the function lazily, only caching values required to minimize function calls, but not storing the entire noise array. This requires an initial time point <code>t0</code> in the domain of <code>W</code>. A second function is needed if the desired SDE algorithm requires multiple processes.</p><pre><code class="language-julia hljs">NoiseTransport{iip}(t0,
    W,
    RV,
    rv,
    Z = nothing;
    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
    reset = true,
    reseed = true,
    noise_prototype = W(nothing, nothing, t0, rv)) where {iip}</code></pre><pre><code class="language-julia hljs">NoiseTransport(t0,
    W,
    RV;
    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
    reset = true,
    reseed = true,
    kwargs...)</code></pre><p>Additionally, one can use an in-place function <code>W(out, u, p, t, rv)</code> for more efficient generation of the arrays for mulitidimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the <code>noise_prototype</code> needs to be set.</p><p><strong>NoiseTransport Example</strong></p><p>The <code>NoiseTransport</code> requires you to pass an initial time, a transport function, and a random variable. The random variable can be either out-of-place or in-place. It is assumed it is out-of-place when the realization is a subtype of <code>Number</code>, and in-place, when it is a subtype of <code>AbstractArray</code>. Here, a random variable is any function that accepts a random number generator, in the out-of-place case (e.g. <code>rand(rng)</code>), or a random number generator and a realization to be mutated (e.g. <code>rand!(rng, rv)</code>).</p><p>An optional realization <code>rv</code> may be given. The realization <code>rv</code> is used in the first time an <code>AbstractRODEProblem</code> is solved. Subsequent runs of the same problem will draw a different realization from the random variable <code>RV</code>, unless <code>reseed</code> is set to false. In the case of a <code>NoiseProblem</code>, however, a new realization will happen at the first run already, and, in this case, <code>rv</code> can be regarded as a realization prototype, which is necessary in the case of a random vector.</p><p>As a first example, let us implement the Gaussian noise <code>W(t) = sin(Yt)</code>, where <code>Y</code> is a normal random variable.</p><pre><code class="language-julia hljs">f(u, p, t, rv) = sin(rv * t)
t0 = 0.0
W = NoiseTransport(t0, f, randn)</code></pre><p>If we want to build a scalar random process out of a random vector, then an in-place version of the random vector is required, as follows. We can also use parameters in the transport function, in which case the <code>noise_prototype</code> must be given.</p><pre><code class="language-julia hljs">using Random: randn!
f(u, p, t, rv) = sin(p[1] * t + rv[1]) + cos(p[2] * t + rv[2])
t0 = 0.0
rv = randn(2)
p = (π, 2π)
W = NoiseTransport(t0, f, randn!, rv, noise_prototype = f(nothing, p, t0, rv))</code></pre><p>If the random process is expected to be mulitidimensional, it is preferable to use an in-place transport function, and, in this case, the <code>noise_prototype</code> must be given. Here is an example with a scalar random vector with a beta distribution, from <code>Distributions.jl</code>.</p><pre><code class="language-julia hljs">f!(out, u, p, t, rv) = (out .= sin.(rv * t))
t0 = 0.0
RV(rng) = rand(rng, Beta(2, 3))
rv = 0.0
W = NoiseTransport(t0, f!, RV, rv, noise_prototype = zeros(4))</code></pre><p>We can also have a random vector with a mulitidimensional process, in which case an in-place version of <code>RV</code> is required. For example.</p><pre><code class="language-julia hljs">using Random: randn!

function f!(out, u, p, t, v)
    out[1] = sin(v[1] * t)
    out[2] = sin(t + v[2])
    out[3] = cos(t) * v[1] + sin(t) * v[2]
    nothing
end

t0 = 0.0
RV!(rng, v) = (v[1] = randn(rng); v[2] = rand(rng))
rv = zeros(2)

W = NoiseTransport(t0, f!, RV!, rv, noise_prototype = zeros(3))</code></pre><p>A <code>NoiseTransport</code> can be used as driving noise for SDEs and RODEs. Have fun!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L683-L777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseGrid" href="#DiffEqNoiseProcess.NoiseGrid"><code>DiffEqNoiseProcess.NoiseGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A noise grid builds a noise process from arrays of points. For example, you can generate your desired noise process as an array <code>W</code> with timepoints <code>t</code>, and use the constructor:</p><pre><code class="language-julia hljs">NoiseGrid(t, W, Z = nothing; reset = true)</code></pre><p>to build the associated noise process. This process comes with a linear interpolation of the given points, and thus the grid does not have to match the grid of integration. Thus, this can be used for adaptive solutions as well. However, one must take note that the fidelity of the noise process is linked to how fine the noise grid is determined: if the noise grid is sparse on points compared to the integration, then its distributional properties may be slightly perturbed by the linear interpolation. Thus, it&#39;s suggested that the grid size at least approximates the number of time steps in the integration to ensure accuracy.</p><p>For a one-dimensional process, <code>W</code> should be an <code>AbstractVector</code> of <code>Number</code>s. For mulitidimensional processes, <code>W</code> should be an <code>AbstractVector</code> of the <code>noise_prototype</code>.</p><p><strong>NoiseGrid</strong></p><p>In this example, we will show you how to define your own version of Brownian motion using an array of pre-calculated points. In normal usage, you should use <code>WienerProcess</code> instead, since this will have distributionally-exact interpolations while the noise grid uses linear interpolations, but this is a nice example of the workflow.</p><p>To define a <code>NoiseGrid</code> you need to have a set of time points and a set of values for the process. Let&#39;s define a Brownian motion on <code>(0.0,1.0)</code> with a <code>dt=0.001</code>. To do this,</p><pre><code class="language-julia hljs">dt = 0.001
t = 0:dt:1
brownian_values = cumsum([0; [sqrt(dt) * randn() for i in 1:(length(t) - 1)]])</code></pre><p>Now we build the <code>NoiseGrid</code> using these values:</p><pre><code class="language-julia hljs">W = NoiseGrid(t, brownian_values)</code></pre><p>We can then pass <code>W</code> as the <code>noise</code> argument of an <code>SDEProblem</code> to use it in an SDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L858-L907">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.NoiseApproximation" href="#DiffEqNoiseProcess.NoiseApproximation"><code>DiffEqNoiseProcess.NoiseApproximation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>In many cases, one would like to define a noise process directly by a stochastic differential equation which does not have an analytical solution. Of course, this will not be distributionally-exact and how well the properties match depends on how well the differential equation is integrated, but in many cases , this can be used as a good approximation when other methods are much more difficult.</p><p>A <code>NoiseApproximation</code> is defined by a <code>DEIntegrator</code>. The constructor for a <code>NoiseApproximation</code> is:</p><pre><code class="language-julia hljs">NoiseApproximation(source1::DEIntegrator,
    source2::Union{DEIntegrator, Nothing} = nothing;
    reset = true)</code></pre><p>The <code>DEIntegrator</code> should have a final time point of integration far enough away, such that it will not halt during the integration. For ease of use, you can use a final time point as <code>Inf</code>. Note that the time points do not have to match the time points of the future integration, since the interpolant of the SDE solution will be used. Thus, the limiting factor is error tolerance, and not hitting specific points.</p><p><strong>NoiseApproximation Example</strong></p><p>In this example, we will show how to use the <code>NoiseApproximation</code> to build our own Geometric Brownian Motion from its stochastic differential equation definition. In normal usage, you should use the <code>GeometricBrownianMotionProcess</code> instead since that is more efficient and distributionally-exact.</p><p>First, let&#39;s define the <code>SDEProblem</code>. Here, we use a timespan <code>(0.0,Inf)</code> so that the noise can be used over an indefinite integral.</p><pre><code class="language-julia hljs">const μ = 1.5
const σ = 1.2
f(u, p, t) = μ * u
g(u, p, t) = σ * u
prob = SDEProblem(f, g, 1.0, (0.0, Inf))</code></pre><p>Now we build the noise process by building the integrator and sending that integrator to the <code>NoiseApproximation</code> constructor:</p><pre><code class="language-julia hljs">integrator = init(prob, SRIW1())
W = NoiseApproximation(integrator)</code></pre><p>We can use this noise process like any other noise process. For example, we can now build a geometric Brownian motion whose noise process is colored noise that itself is a geometric Brownian motion:</p><pre><code class="language-julia hljs">prob = SDEProblem(f, g, 1.0, (0.0, Inf), noise = W)</code></pre><p>The possibilities are endless.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L966-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.VirtualBrownianTree" href="#DiffEqNoiseProcess.VirtualBrownianTree"><code>DiffEqNoiseProcess.VirtualBrownianTree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>VirtualBrownianTree</code> builds the noise process starting from an initial time <code>t0</code>, the first value of the process <code>W0</code>, and (optionally) the first value <code>Z0</code> for an auxiliary pseudo-process. The constructor is given as</p><pre><code class="language-julia hljs">VirtualBrownianTree(t0,
    W0,
    Z0 = nothing,
    dist = WHITE_NOISE_DIST,
    bridge = VBT_BRIDGE;
    kwargs...)</code></pre><p>where <code>dist</code> specifies the distribution that is used to generate the end point(s) <code>Wend</code> (<code>Zend</code>) of the noise process for the final time <code>tend</code>. <code>bridge</code> denotes the distribution of the employed Brownian bridge.  Per default <code>tend</code> is fixed to <code>t0+1</code> but can be changed by passing a custom <code>tend</code> as a keyword argument. The following keyword arguments are available:</p><ul><li><code>tend</code> is the end time of the noise process.</li><li><code>Wend</code> is the end value of the noise process.</li><li><code>Zend</code> is the end value of the pseudo-noise process.</li><li><code>atol</code> represents the absolute tolerance determining when the recursion is terminated.</li><li><code>tree_depth</code> allows one to store a cache of seeds, noise values, and times to speed up the simulation by reducing the recursion steps.</li><li><code>search_depth</code> maximal search depth for the tree if <code>atol</code> is not reached.</li><li><code>rng</code> the splittable PRNG used for generating the random numbers. Default: <code>Threefry4x()</code> from the Random123 package.</li></ul><p><strong>VirtualBrownianTree Example</strong></p><p>In this example, we define a mulitidimensional Brownian process based on a <code>VirtualBrownianTree</code> with a minimal <code>tree_depth=0</code> such that memory consumption is minimized.</p><pre><code class="language-julia hljs">W0 = zeros(10)
W = VirtualBrownianTree(0.0, W0; tree_depth = 0)

prob = NoiseProblem(W, (0.0, 1.0))
sol = solve(prob; dt = 1 / 10)</code></pre><p>Using a look-up cache by increasing <code>tree_depth</code> can significantly reduce the runtime. Thus, the <code>VirtualBrownianTree</code> allows for trading off speed for memory in a simple manner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L1076-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.SimpleNoiseProcess" href="#DiffEqNoiseProcess.SimpleNoiseProcess"><code>DiffEqNoiseProcess.SimpleNoiseProcess</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleNoiseProcess{T, N, Tt, T2, T3, ZType, F, F2, inplace, RNGType} &lt;:
AbstractNoiseProcess{T, N, Vector{T2}, inplace}</code></pre><p>Like <code>NoiseProcess</code> but without support for adaptivity. This makes it lightweight and slightly faster.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>SimpleNoiseProcess</code> should not be used with adaptive SDE solvers as it will lead to incorrect results.</p></div></div><pre><code class="language-julia hljs">SimpleNoiseProcess{iip}(t0, W0, Z0, dist, bridge;
    save_everystep = true,
    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
    reset = true, reseed = true) where {iip}</code></pre><ul><li><code>t0</code> is the first timepoint</li><li><code>W0</code> is the first value of the process.</li><li><code>Z0</code> is the first value of the pseudo-process. This is necessary for higher order algorithms. If it&#39;s not needed, set to <code>nothing</code>.</li><li><code>dist</code> the distribution for the steps over time.</li><li><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</li><li><code>save_everystep</code> whether to save every step of the Brownian timeseries.</li><li><code>rng</code> the local RNG used for generating the random numbers.</li><li><code>reset</code> whether to reset the process with each solve.</li><li><code>reseed</code> whether to reseed the process with each solve.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L315-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.BoxWedgeTail" href="#DiffEqNoiseProcess.BoxWedgeTail"><code>DiffEqNoiseProcess.BoxWedgeTail</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxWedgeTail{T, N, Tt, TA, T2, T3, ZType, F, F2, inplace, RNGType, tolType, spacingType,
    jpdfType, boxType, wedgeType, tailType, distBWTType, distΠType} &lt;:
AbstractNoiseProcess{T, N, Vector{T2}, inplace}</code></pre><p>The method for random generation of stochastic area integrals due to Gaines and Lyons. The method is based on Marsaglia&#39;s &quot;rectangle-wedge-tail&quot; approach for two dimensions.</p><p>3 different groupings for the boxes are implemented.</p><ul><li>box_grouping = :Columns (full, i.e., as large as possible, columns on a square spanned by dr and da)</li><li>box_grouping = :none (no grouping)</li><li>box_grouping = :MinEntropy (default, grouping that achieves a smaller entropy than the column wise grouping and thus allows for slightly faster sampling – but has a slightly larger number of groups)</li></ul><p>The sampling is based on the Distributions.jl package, i.e., to sample from one of the many distributions, a uni-/bi-variate distribution from Distributions.jl is constructed, and then rand(..) is used.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">BoxWedgeTail{iip}(t0, W0, Z0, dist, bridge;
    rtol = 1e-8, nr = 4, na = 4, nz = 10,
    box_grouping = :MinEntropy,
    sqeezing = true,
    save_everystep = true,
    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
    reset = true, reseed = true) where {iip}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/types.jl#L1236-L1266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DiffEqNoiseProcess.pCN" href="#DiffEqNoiseProcess.pCN"><code>DiffEqNoiseProcess.pCN</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pCN(noise::AbstractNoiseProcess, ρ; reset=true,reverse=false,indx=nothing)</code></pre><p>Create a new, but correlated noise process from <code>noise</code> and additional entropy with correlation ρ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/pCN.jl#L37-L41">source</a></section><section><div><pre><code class="language-julia hljs">pCN(noise::NoiseGrid, ρ; reset=true, rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)))</code></pre><p>Create a new, but correlated noise process from <code>noise</code> and additional entropy with correlation ρ. This update defines an autoregressive process in the space of Wiener (or noise process) trajectories, which can be used as proposal distribution in Metropolis-Hastings algorithms (often called the &quot;preconditioned Crank–Nicolson scheme&quot;.)</p><p>External links</p><ul><li><a href="https://en.wikipedia.org/wiki/Preconditioned_Crank%E2%80%93Nicolson_algorithm">Preconditioned Crank–Nicolson algorithm on Wikipedia</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqNoiseProcess.jl/blob/41903870a5a8b8000e6ecc4e1bc82b9fb9926bfb/src/pCN.jl#L54-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noise_processes/">« Classic Noise Processes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Monday 2 September 2024 03:34">Monday 2 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
