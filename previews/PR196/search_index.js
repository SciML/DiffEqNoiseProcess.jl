var documenterSearchIndex = {"docs":
[{"location":"abstract_noise_processes/#Abstract-Noise-Processes","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"","category":"section"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"In addition to the NoiseProcess type, more general AbstractNoiseProcesses are defined. The NoiseGrid allows you to define a noise process from a set of pre-calculated points (the \"normal\" way). The NoiseApproximation allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations.","category":"page"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"The NoiseWrapper allows one to wrap a NoiseProcess from a previous simulation to reuse it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example by solving with a smaller dt) in a distributionally-exact manner. It is demonstrated how the NoiseWrapper can be used to wrap the NoiseProcess of one SDE/RODE solution to reuse the same noise process in another simulation.","category":"page"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"The VirtualBrownianTree allows one to trade speed for O(1) memory usage. Instead of storing Brownian motion increments, the VirtualBrownianTree samples recursively from the midpoint tmid of Brownian bridges, using a splittable PRNG. The recursion terminates when the query time agrees within some tolerance with tmid or when the maximum depth of the tree is reached.","category":"page"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"Lastly, the NoiseFunction allows you to use any function of time as the noise process, while NoiseTransport lets you define a random process as the transport of a random variable or a random vector by a time-dependent function. Together, these functionalities allow you to define any colored noise process and use it efficiently and accurately in your simulations.","category":"page"},{"location":"abstract_noise_processes/#The-Standard-AbstractNoiseProcess","page":"Abstract Noise Processes","title":"The Standard AbstractNoiseProcess","text":"","category":"section"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"NoiseProcess","category":"page"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseProcess","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseProcess","text":"NoiseProcess{T, N, Tt, T2, T3, ZType, F, F2, inplace, S1, S2, RSWM, C, RNGType} <:\n{T, N, Vector{T2}, inplace}\n\nA NoiseProcess is a type defined as:\n\nNoiseProcess(t0, W0, Z0, dist, bridge;\n    iip = SciMLBase.isinplace(dist, 3),\n    rswm = RSWM(), save_everystep = true,\n    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),\n    reset = true, reseed = true)\n\nt0 is the first timepoint\nW0 is the first value of the process.\nZ0 is the first value of the pseudo-process. This is necessary for higher order algorithms. If it's not needed, set to nothing.\ndist the distribution of the steps over time.\nbridge the bridging distribution. Optional, but required for adaptivity and interpolating at new values.\nsave_everystep whether to save every step of the Brownian timeseries.\nrng the local RNG used for generating the random numbers.\nreset whether to reset the process with each solve.\nreseed whether to reseed the process with each solve.\n\nThe signature for the dist is\n\ndist!(rand_vec, W, dt, rng)\n\nfor inplace functions, and\n\nrand_vec = dist(W, dt, rng)\n\notherwise. The signature for bridge is\n\nbridge!(rand_vec, W, W0, Wh, q, h, rng)\n\nand the out of place syntax is\n\nrand_vec = bridge!(W, W0, Wh, q, h, rng)\n\nHere, W is the noise process, W0 is the left side of the current interval, Wh is the right side of the current interval, h is the interval length, and q is the proportion from the left where the interpolation is occurring.\n\nDirect Construction Example\n\nThe easiest way to show how to directly construct a NoiseProcess is by example. Here we will show how to directly construct a NoiseProcess which generates Gaussian white noise.\n\nThis is the noise process, that uses randn!. A special dispatch is added for complex numbers for (randn()+im*randn())/sqrt(2). This function is DiffEqNoiseProcess.wiener_randn (or with ! respectively).\n\nThe first function that must be defined is the noise distribution. This is how to generate W(t+dt) given that we know W(x) for xt₀t. For Gaussian white noise, we know that\n\nW(dt)  N(0dt)\n\nfor W(0)=0 which defines the stepping distribution. Thus, its noise distribution function is:\n\n@inline function WHITE_NOISE_DIST(W, dt, rng)\n    if W.dW isa AbstractArray && !(W.dW isa SArray)\n        return @fastmath sqrt(abs(dt)) * wiener_randn(rng, W.dW)\n    else\n        return @fastmath sqrt(abs(dt)) * wiener_randn(rng, typeof(W.dW))\n    end\nend\n\nfor the out of place versions, and for the inplace versions\n\nfunction INPLACE_WHITE_NOISE_DIST(rand_vec, W, dt, rng)\n    wiener_randn!(rng, rand_vec)\n    sqrtabsdt = @fastmath sqrt(abs(dt))\n    @. rand_vec *= sqrtabsdt\nend\n\nOptionally, we can provide a bridging distribution. This is the distribution of W(qh) for q01 given that we know W(0)=0 and W(h)=Wₕ. For Brownian motion, this is known as the Brownian Bridge, and is well known to have the distribution:\n\nW(qh)  N(qWₕ(1-q)qh)\n\nThus, we have the out-of-place and in-place versions as:\n\nfunction WHITE_NOISE_BRIDGE(W, W0, Wh, q, h, rng)\n    if W.dW isa AbstractArray\n        return @fastmath sqrt((1 - q) * q * abs(h)) * wiener_randn(rng, W.dW) + q * Wh\n    else\n        return @fastmath sqrt((1 - q) * q * abs(h)) * wiener_randn(rng, typeof(W.dW)) +\n                         q * Wh\n    end\nend\nfunction INPLACE_WHITE_NOISE_BRIDGE(rand_vec, W, W0, Wh, q, h, rng)\n    wiener_randn!(rng, rand_vec)\n    #rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*Wh\n    sqrtcoeff = @fastmath sqrt((1 - q) * q * abs(h))\n    @. rand_vec = sqrtcoeff * rand_vec + q * Wh\nend\n\nThese functions are then placed in a noise process:\n\nNoiseProcess(t0, W0, Z0, WHITE_NOISE_DIST, WHITE_NOISE_BRIDGE; kwargs)\nNoiseProcess(t0, W0, Z0, INPLACE_WHITE_NOISE_DIST, INPLACE_WHITE_NOISE_BRIDGE; kwargs)\n\nNotice that we can optionally provide an alternative adaptive algorithm for the timestepping rejections. RSWM() defaults to the Rejection Sampling with Memory 3 algorithm (RSwM3).\n\nNote that the standard constructors are simply:\n\nfunction WienerProcess(t0, W0, Z0 = nothing)\n    NoiseProcess(t0, W0, Z0, WHITE_NOISE_DIST, WHITE_NOISE_BRIDGE; kwargs)\nend\nfunction WienerProcess!(t0, W0, Z0 = nothing)\n    NoiseProcess(t0, W0, Z0, INPLACE_WHITE_NOISE_DIST, INPLACE_WHITE_NOISE_BRIDGE; kwargs)\nend\n\nThese will generate a Wiener process, which can be stepped with step!(W,dt), and interpolated as W(t).\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#Alternative-AbstractNoiseProcess-Types","page":"Abstract Noise Processes","title":"Alternative AbstractNoiseProcess Types","text":"","category":"section"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"In addition to the mathematically-defined noise processes above, there exists more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations.","category":"page"},{"location":"abstract_noise_processes/","page":"Abstract Noise Processes","title":"Abstract Noise Processes","text":"NoiseWrapper\nNoiseFunction\nNoiseTransport\nNoiseGrid\nNoiseApproximation\nVirtualBrownianTree\nSimpleNoiseProcess\nBoxWedgeTail\npCN","category":"page"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseWrapper","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseWrapper","text":"NoiseWrapper{T, N, Tt, T2, T3, T4, ZType, inplace} <:\nAbstractNoiseProcess{T, N, Vector{T2}, inplace}\n\nThis produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to reuse a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.\n\nConstructor\n\nNoiseWrapper(source::AbstractNoiseProcess{T, N, Vector{T2}, inplace};\n    reset = true, reverse = false, indx = nothing) where {T, N, T2, inplace}\n\nNoiseWrapper Example\n\nIn this example, we will solve an SDE three times:\n\nFirst, to generate a noise process\nSecond, with the same timesteps to show the values are the same\nThird, with half-sized timesteps\n\nFirst, we will generate a noise process by solving an SDE:\n\nusing StochasticDiffEq, DiffEqNoiseProcess\nf1(u, p, t) = 1.01u\ng1(u, p, t) = 1.01u\ndt = 1 // 2^(4)\nprob1 = SDEProblem(f1, g1, 1.0, (0.0, 1.0))\nsol1 = solve(prob1, EM(), dt = dt, save_noise = true)\n\nNow we wrap the noise into a NoiseWrapper and solve the same problem:\n\nW2 = NoiseWrapper(sol1.W)\nprob1 = SDEProblem(f1, g1, 1.0, (0.0, 1.0), noise = W2)\nsol2 = solve(prob1, EM(), dt = dt)\n\nWe can test\n\n@test sol1.u ≈ sol2.u\n\nto see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller dt:\n\nW3 = NoiseWrapper(sol1.W)\nprob2 = SDEProblem(f1, g1, 1.0, (0.0, 1.0), noise = W3)\n\ndt = 1 // 2^(5)\nsol3 = solve(prob2, EM(), dt = dt)\n\nWe can plot the results to see what this looks like:\n\nusing Plots\nplot(sol1)\nplot!(sol2)\nplot!(sol3)\n\n(Image: noise_process)\n\nIn this plot, sol2 covers up sol1 because they hit essentially the same values. You can see that sol3 is similar to the others, because it's using the same underlying noise process, just sampled much finer.\n\nTo double-check, we see that:\n\nplot(sol1.W)\nplot!(sol2.W)\nplot!(sol3.W)\n\n(Image: coupled_wiener)\n\nthe coupled Wiener processes coincide at every other time point, and the intermediate timepoints were calculated according to a Brownian bridge.\n\nAdaptive NoiseWrapper Example\n\nHere we will show that the same noise can be used with the adaptive methods using the NoiseWrapper. SRI and SRIW1 use slightly different error estimators, and thus have slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:\n\nprob = SDEProblem(f1, g1, ones(2), (0.0, 1.0))\nsol4 = solve(prob, SRI(), abstol = 1e-8, save_noise = true)\n\nW2 = NoiseWrapper(sol4.W)\nprob2 = SDEProblem(f1, g1, ones(2), (0.0, 1.0), noise = W2)\nsol5 = solve(prob2, SRIW1(), abstol = 1e-8)\n\nusing Plots\nplot(sol4)\nplot!(sol5)\n\n(Image: SRI_SRIW1_diff)\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseFunction","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseFunction","text":"NoiseFunction{T, N, wType, zType, Tt, T2, T3, inplace} <:\nAbstractNoiseProcess{T, N, nothing, inplace}\n\nThis allows you to use any arbitrary function W(t) as a NoiseProcess. This will use the function lazily, only caching values required to minimize function calls, but not storing the entire noise array. This requires an initial time point t0 in the domain of W. A second function is needed if the desired SDE algorithm requires multiple processes.\n\nNoiseFunction{iip}(t0, W, Z = nothing;\n    noise_prototype = W(nothing, nothing, t0),\n    reset = true) where {iip}\n\nAdditionally, one can use an in-place function W(out1,out2,t) for more efficient generation of the arrays for mulitidimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the noise_prototype needs to be set.\n\nNoiseFunction Example\n\nThe NoiseFunction is pretty simple: pass a function. As a silly example, we can use exp as a noise process by doing:\n\nf(u,p,t) = exp(t)\nW = NoiseFunction(0.0, f)\n\nIf it's mulitidimensional and an in-place function is used, the noise_prototype must be given. For example:\n\nf(out,u,p,t) = (out .= exp(t))\nW = NoiseFunction(0.0, f, noise_prototype = rand(4))\n\nThis allows you to put arbitrarily weird noise into SDEs and RODEs. Have fun.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseTransport","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseTransport","text":"NoiseTransport{T, N, wType, zType, Tt, T2, T3, TRV, Trv, RNGType, inplace} <:\nAbstractNoiseProcess{T, N, nothing, inplace}\n\nThis allows you to define stochastic processes of the form W(t) = f(u, p, t, RV), where f is a function and RV represents a random variable. This will use the function lazily, only caching values required to minimize function calls, but not storing the entire noise array. This requires an initial time point t0 in the domain of W. A second function is needed if the desired SDE algorithm requires multiple processes.\n\nNoiseTransport{iip}(t0,\n    W,\n    RV,\n    rv,\n    Z = nothing;\n    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),\n    reset = true,\n    reseed = true,\n    noise_prototype = W(nothing, nothing, t0, rv)) where {iip}\n\nNoiseTransport(t0,\n    W,\n    RV;\n    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),\n    reset = true,\n    reseed = true,\n    kwargs...)\n\nAdditionally, one can use an in-place function W(out, u, p, t, rv) for more efficient generation of the arrays for mulitidimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the noise_prototype needs to be set.\n\nNoiseTransport Example\n\nThe NoiseTransport requires you to pass an initial time, a transport function, and a random variable. The random variable can be either out-of-place or in-place. It is assumed it is out-of-place when the realization is a subtype of Number, and in-place, when it is a subtype of AbstractArray. Here, a random variable is any function that accepts a random number generator, in the out-of-place case (e.g. rand(rng)), or a random number generator and a realization to be mutated (e.g. rand!(rng, rv)).\n\nAn optional realization rv may be given. The realization rv is used in the first time an AbstractRODEProblem is solved. Subsequent runs of the same problem will draw a different realization from the random variable RV, unless reseed is set to false. In the case of a NoiseProblem, however, a new realization will happen at the first run already, and, in this case, rv can be regarded as a realization prototype, which is necessary in the case of a random vector.\n\nAs a first example, let us implement the Gaussian noise W(t) = sin(Yt), where Y is a normal random variable.\n\nf(u, p, t, rv) = sin(rv * t)\nt0 = 0.0\nW = NoiseTransport(t0, f, randn)\n\nIf we want to build a scalar random process out of a random vector, then an in-place version of the random vector is required, as follows. We can also use parameters in the transport function, in which case the noise_prototype must be given.\n\nusing Random: randn!\nf(u, p, t, rv) = sin(p[1] * t + rv[1]) + cos(p[2] * t + rv[2])\nt0 = 0.0\nrv = randn(2)\np = (π, 2π)\nW = NoiseTransport(t0, f, randn!, rv, noise_prototype = f(nothing, p, t0, rv))\n\nIf the random process is expected to be mulitidimensional, it is preferable to use an in-place transport function, and, in this case, the noise_prototype must be given. Here is an example with a scalar random vector with a beta distribution, from Distributions.jl.\n\nf!(out, u, p, t, rv) = (out .= sin.(rv * t))\nt0 = 0.0\nRV(rng) = rand(rng, Beta(2, 3))\nrv = 0.0\nW = NoiseTransport(t0, f!, RV, rv, noise_prototype = zeros(4))\n\nWe can also have a random vector with a mulitidimensional process, in which case an in-place version of RV is required. For example.\n\nusing Random: randn!\n\nfunction f!(out, u, p, t, v)\n    out[1] = sin(v[1] * t)\n    out[2] = sin(t + v[2])\n    out[3] = cos(t) * v[1] + sin(t) * v[2]\n    nothing\nend\n\nt0 = 0.0\nRV!(rng, v) = (v[1] = randn(rng); v[2] = rand(rng))\nrv = zeros(2)\n\nW = NoiseTransport(t0, f!, RV!, rv, noise_prototype = zeros(3))\n\nA NoiseTransport can be used as driving noise for SDEs and RODEs. Have fun!\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseGrid","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseGrid","text":"A noise grid builds a noise process from arrays of points. For example, you can generate your desired noise process as an array W with timepoints t, and use the constructor:\n\nNoiseGrid(t, W, Z = nothing; reset = true)\n\nto build the associated noise process. This process comes with a linear interpolation of the given points, and thus the grid does not have to match the grid of integration. Thus, this can be used for adaptive solutions as well. However, one must take note that the fidelity of the noise process is linked to how fine the noise grid is determined: if the noise grid is sparse on points compared to the integration, then its distributional properties may be slightly perturbed by the linear interpolation. Thus, it's suggested that the grid size at least approximates the number of time steps in the integration to ensure accuracy.\n\nFor a one-dimensional process, W should be an AbstractVector of Numbers. For mulitidimensional processes, W should be an AbstractVector of the noise_prototype.\n\nNoiseGrid\n\nIn this example, we will show you how to define your own version of Brownian motion using an array of pre-calculated points. In normal usage, you should use WienerProcess instead, since this will have distributionally-exact interpolations while the noise grid uses linear interpolations, but this is a nice example of the workflow.\n\nTo define a NoiseGrid you need to have a set of time points and a set of values for the process. Let's define a Brownian motion on (0.0,1.0) with a dt=0.001. To do this,\n\ndt = 0.001\nt = 0:dt:1\nbrownian_values = cumsum([0; [sqrt(dt) * randn() for i in 1:(length(t) - 1)]])\n\nNow we build the NoiseGrid using these values:\n\nW = NoiseGrid(t, brownian_values)\n\nWe can then pass W as the noise argument of an SDEProblem to use it in an SDE.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.NoiseApproximation","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.NoiseApproximation","text":"In many cases, one would like to define a noise process directly by a stochastic differential equation which does not have an analytical solution. Of course, this will not be distributionally-exact and how well the properties match depends on how well the differential equation is integrated, but in many cases , this can be used as a good approximation when other methods are much more difficult.\n\nA NoiseApproximation is defined by a DEIntegrator. The constructor for a NoiseApproximation is:\n\nNoiseApproximation(source1::DEIntegrator,\n    source2::Union{DEIntegrator, Nothing} = nothing;\n    reset = true)\n\nThe DEIntegrator should have a final time point of integration far enough away, such that it will not halt during the integration. For ease of use, you can use a final time point as Inf. Note that the time points do not have to match the time points of the future integration, since the interpolant of the SDE solution will be used. Thus, the limiting factor is error tolerance, and not hitting specific points.\n\nNoiseApproximation Example\n\nIn this example, we will show how to use the NoiseApproximation to build our own Geometric Brownian Motion from its stochastic differential equation definition. In normal usage, you should use the GeometricBrownianMotionProcess instead since that is more efficient and distributionally-exact.\n\nFirst, let's define the SDEProblem. Here, we use a timespan (0.0,Inf) so that the noise can be used over an indefinite integral.\n\nconst μ = 1.5\nconst σ = 1.2\nf(u, p, t) = μ * u\ng(u, p, t) = σ * u\nprob = SDEProblem(f, g, 1.0, (0.0, Inf))\n\nNow we build the noise process by building the integrator and sending that integrator to the NoiseApproximation constructor:\n\nintegrator = init(prob, SRIW1())\nW = NoiseApproximation(integrator)\n\nWe can use this noise process like any other noise process. For example, we can now build a geometric Brownian motion whose noise process is colored noise that itself is a geometric Brownian motion:\n\nprob = SDEProblem(f, g, 1.0, (0.0, Inf), noise = W)\n\nThe possibilities are endless.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.VirtualBrownianTree","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.VirtualBrownianTree","text":"A VirtualBrownianTree builds the noise process starting from an initial time t0, the first value of the process W0, and (optionally) the first value Z0 for an auxiliary pseudo-process. The constructor is given as\n\nVirtualBrownianTree(t0,\n    W0,\n    Z0 = nothing,\n    dist = WHITE_NOISE_DIST,\n    bridge = VBT_BRIDGE;\n    kwargs...)\n\nwhere dist specifies the distribution that is used to generate the end point(s) Wend (Zend) of the noise process for the final time tend. bridge denotes the distribution of the employed Brownian bridge.  Per default tend is fixed to t0+1 but can be changed by passing a custom tend as a keyword argument. The following keyword arguments are available:\n\ntend is the end time of the noise process.\nWend is the end value of the noise process.\nZend is the end value of the pseudo-noise process.\natol represents the absolute tolerance determining when the recursion is terminated.\ntree_depth allows one to store a cache of seeds, noise values, and times to speed up the simulation by reducing the recursion steps.\nsearch_depth maximal search depth for the tree if atol is not reached.\nrng the splittable PRNG used for generating the random numbers. Default: Threefry4x() from the Random123 package.\n\nVirtualBrownianTree Example\n\nIn this example, we define a mulitidimensional Brownian process based on a VirtualBrownianTree with a minimal tree_depth=0 such that memory consumption is minimized.\n\nW0 = zeros(10)\nW = VirtualBrownianTree(0.0, W0; tree_depth = 0)\n\nprob = NoiseProblem(W, (0.0, 1.0))\nsol = solve(prob; dt = 1 / 10)\n\nUsing a look-up cache by increasing tree_depth can significantly reduce the runtime. Thus, the VirtualBrownianTree allows for trading off speed for memory in a simple manner.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.SimpleNoiseProcess","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.SimpleNoiseProcess","text":"SimpleNoiseProcess{T, N, Tt, T2, T3, ZType, F, F2, inplace, RNGType} <:\nAbstractNoiseProcess{T, N, Vector{T2}, inplace}\n\nLike NoiseProcess but without support for adaptivity. This makes it lightweight and slightly faster.\n\nwarn: Warn\nSimpleNoiseProcess should not be used with adaptive SDE solvers as it will lead to incorrect results.\n\nSimpleNoiseProcess{iip}(t0, W0, Z0, dist, bridge;\n    save_everystep = true,\n    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),\n    reset = true, reseed = true) where {iip}\n\nt0 is the first timepoint\nW0 is the first value of the process.\nZ0 is the first value of the pseudo-process. This is necessary for higher order algorithms. If it's not needed, set to nothing.\ndist the distribution for the steps over time.\nbridge the bridging distribution. Optional, but required for adaptivity and interpolating at new values.\nsave_everystep whether to save every step of the Brownian timeseries.\nrng the local RNG used for generating the random numbers.\nreset whether to reset the process with each solve.\nreseed whether to reseed the process with each solve.\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.BoxWedgeTail","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.BoxWedgeTail","text":"BoxWedgeTail{T, N, Tt, TA, T2, T3, ZType, F, F2, inplace, RNGType, tolType, spacingType,\n    jpdfType, boxType, wedgeType, tailType, distBWTType, distΠType} <:\nAbstractNoiseProcess{T, N, Vector{T2}, inplace}\n\nThe method for random generation of stochastic area integrals due to Gaines and Lyons. The method is based on Marsaglia's \"rectangle-wedge-tail\" approach for two dimensions.\n\n3 different groupings for the boxes are implemented.\n\nbox_grouping = :Columns (full, i.e., as large as possible, columns on a square spanned by dr and da)\nbox_grouping = :none (no grouping)\nbox_grouping = :MinEntropy (default, grouping that achieves a smaller entropy than the column wise grouping and thus allows for slightly faster sampling – but has a slightly larger number of groups)\n\nThe sampling is based on the Distributions.jl package, i.e., to sample from one of the many distributions, a uni-/bi-variate distribution from Distributions.jl is constructed, and then rand(..) is used.\n\nConstructor\n\nBoxWedgeTail{iip}(t0, W0, Z0, dist, bridge;\n    rtol = 1e-8, nr = 4, na = 4, nz = 10,\n    box_grouping = :MinEntropy,\n    sqeezing = true,\n    save_everystep = true,\n    rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),\n    reset = true, reseed = true) where {iip}\n\n\n\n\n\n","category":"type"},{"location":"abstract_noise_processes/#DiffEqNoiseProcess.pCN","page":"Abstract Noise Processes","title":"DiffEqNoiseProcess.pCN","text":"pCN(noise::AbstractNoiseProcess, ρ; reset=true,reverse=false,indx=nothing)\n\nCreate a new, but correlated noise process from noise and additional entropy with correlation ρ.\n\n\n\n\n\npCN(noise::NoiseGrid, ρ; reset=true, rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)))\n\nCreate a new, but correlated noise process from noise and additional entropy with correlation ρ. This update defines an autoregressive process in the space of Wiener (or noise process) trajectories, which can be used as proposal distribution in Metropolis-Hastings algorithms (often called the \"preconditioned Crank–Nicolson scheme\".)\n\nExternal links\n\nPreconditioned Crank–Nicolson algorithm on Wikipedia\n\n\n\n\n\n","category":"function"},{"location":"#DiffEqNoiseProcess.jl:-Noise-Processes-for-Stochastic-Modeling","page":"Home","title":"DiffEqNoiseProcess.jl: Noise Processes for Stochastic Modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Noise processes are essential in continuous stochastic modeling. The NoiseProcess types are distributionally-exact, meaning they are not solutions of stochastic differential equations but instead are directly generated according to their analytical distributions. These processes are used as the noise term in the SDE and RODE solvers. Additionally, the noise processes themselves can be simulated and solved using the DiffEq common interface (including the Monte Carlo interface).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install DiffEqNoiseProcess.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DiffEqNoiseProcess\")","category":"page"},{"location":"#Using-Noise-Processes","page":"Home","title":"Using Noise Processes","text":"","category":"section"},{"location":"#Passing-a-Noise-Process-to-a-Problem-Type","page":"Home","title":"Passing a Noise Process to a Problem Type","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AbstractNoiseProcesses can be passed directly to the problem types to replace the standard Wiener process (Brownian motion) with your choice of noise. To do this, simply construct the noise and pass it to the noise keyword argument:","category":"page"},{"location":"","page":"Home","title":"Home","text":"μ = 1.0\nσ = 2.0\nW = GeometricBrownianMotionProcess(μ, σ, 0.0, 1.0, 1.0)\n# ...\n# Define f,g,u0,tspan for a SDEProblem\n# ...\nprob = SDEProblem(f, g, u0, tspan, noise = W)","category":"page"},{"location":"#Basic-Interface","page":"Home","title":"Basic Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The NoiseProcess acts like a DiffEq solution. For some noise process W, you can get its ith timepoint like W[i] and the associated time W.t[i]. If the NoiseProcess has a bridging distribution defined, it can be interpolated to arbitrary time points using W(t). Note that every interpolated value is saved to the NoiseProcess so that way it can stay distributionally correct. A plot recipe is provided that plots the timeseries.","category":"page"},{"location":"#Direct-Simulation-of-the-Noise-Process","page":"Home","title":"Direct Simulation of the Noise Process","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the NoiseProcess types are distribution-exact and do not require the stochastic differential equation solvers, many times one would like to directly simulate trajectories from these processes. The NoiseProcess has a NoiseProblem type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"NoiseProblem(noise, tspan)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for which solve works. For example, we can simulate a distributionally-exact Geometric Brownian Motion solution by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"μ = 1.0\nσ = 2.0\nW = GeometricBrownianMotionProcess(μ, σ, 0.0, 1.0, 1.0)\nprob = NoiseProblem(W, (0.0, 1.0))\nsol = solve(prob; dt = 0.1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve requires that the dt is given, and that the solution it returns is a NoiseProcess which has stepped through the timespan. Because this follows the common interface, all of the normal functionality works. For example, we can use the Monte Carlo functionality as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"enprob = EnsembleProblem(prob)\nsol = solve(enprob; dt = 0.1, num_monte = 100)","category":"page"},{"location":"","page":"Home","title":"Home","text":"simulates 100 Geometric Brownian Motions.","category":"page"},{"location":"#Direct-Interface","page":"Home","title":"Direct Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most of the time, a NoiseProcess is received from the solution of a stochastic or random differential equation, in which case sol.W gives the NoiseProcess and it is already defined along some timeseries. In other cases, NoiseProcess types are directly simulated (see below). However, NoiseProcess types can also be directly acted on. The basic functionality is given by calculate_step! to calculate a future time point, and accept_step! to accept the step. If steps are rejected, the Rejection Sampling with Memory algorithm is applied to keep the solution distributionally exact. This kind of stepping is done via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"W = WienerProcess(0.0, 1.0, 1.0)\ndt = 0.1\nW.dt = dt\nu = nothing;\np = nothing; # for state-dependent distributions\ncalculate_step!(W, dt, u, p)\nfor i in 1:10\n    accept_step!(W, dt, u, p)\nend","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"noise_processes/#Classic-Noise-Processes","page":"Classic Noise Processes","title":"Classic Noise Processes","text":"","category":"section"},{"location":"noise_processes/","page":"Classic Noise Processes","title":"Classic Noise Processes","text":"This section describes the available NoiseProcess types. Note that all keyword arguments are splatted into the NoiseProcess constructor, and thus options like reset are available on the pre-built processes.","category":"page"},{"location":"noise_processes/","page":"Classic Noise Processes","title":"Classic Noise Processes","text":"WienerProcess\nWienerProcess!\nRealWienerProcess\nRealWienerProcess!\nOrnsteinUhlenbeckProcess\nOrnsteinUhlenbeckProcess!\nGeometricBrownianMotionProcess\nGeometricBrownianMotionProcess!\nCorrelatedWienerProcess\nCorrelatedWienerProcess!\nSimpleWienerProcess\nSimpleWienerProcess!\nCompoundPoissonProcess\nCompoundPoissonProcess!","category":"page"},{"location":"noise_processes/#DiffEqNoiseProcess.WienerProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.WienerProcess","text":"The WienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nWienerProcess(t0,W0,Z0=nothing;kwargs...)\nWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.WienerProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.WienerProcess!","text":"The WienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nWienerProcess(t0,W0,Z0=nothing;kwargs...)\nWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.RealWienerProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.RealWienerProcess","text":"The RealWienerProcess is a Brownian motion that is forced to be real-valued. While the normal WienerProcess becomes complex valued if W0 is complex, this version is real valued for when you want to, for example, solve an SDE defined by complex numbers where the noise is in the reals.\n\nRealWienerProcess(t0,W0,Z0=nothing;kwargs...)\nRealWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.RealWienerProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.RealWienerProcess!","text":"The RealWienerProcess is a Brownian motion that is forced to be real-valued. While the normal WienerProcess becomes complex valued if W0 is complex, this version is real valued for when you want to, for example, solve an SDE defined by complex numbers where the noise is in the reals.\n\nRealWienerProcess(t0,W0,Z0=nothing;kwargs...)\nRealWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.OrnsteinUhlenbeckProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckProcess","text":"a Ornstein-Uhlenbeck process, which is a Wiener process defined by the stochastic differential equation\n\ndX_t = theta (mu - X_t) dt + sigma dW_t\n\nThe OrnsteinUhlenbeckProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). The constructor is:\n\nOrnsteinUhlenbeckProcess(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\nOrnsteinUhlenbeckProcess!(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.OrnsteinUhlenbeckProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckProcess!","text":"A Ornstein-Uhlenbeck process, which is a Wiener process defined by the stochastic differential equation\n\ndX_t = theta (mu - X_t) dt + sigma dW_t\n\nThe OrnsteinUhlenbeckProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). The constructor is:\n\nOrnsteinUhlenbeckProcess(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\nOrnsteinUhlenbeckProcess!(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.GeometricBrownianMotionProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.GeometricBrownianMotionProcess","text":"A GeometricBrownianMotion process is a Wiener process with constant drift μ and constant diffusion σ. I.e. this is the solution of the stochastic differential equation\n\ndX_t = mu X_t dt + sigma X_t dW_t\n\nThe GeometricBrownianMotionProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:\n\nGeometricBrownianMotionProcess(μ,σ,t0,W0,Z0=nothing;kwargs...)\nGeometricBrownianMotionProcess!(μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.GeometricBrownianMotionProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.GeometricBrownianMotionProcess!","text":"A GeometricBrownianMotion process is a Wiener process with constant drift μ and constant diffusion σ. I.e. this is the solution of the stochastic differential equation\n\ndX_t = mu X_t dt + sigma X_t dW_t\n\nThe GeometricBrownianMotionProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:\n\nGeometricBrownianMotionProcess(μ,σ,t0,W0,Z0=nothing;kwargs...)\nGeometricBrownianMotionProcess!(μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.CorrelatedWienerProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.CorrelatedWienerProcess","text":"One can define a CorrelatedWienerProcess which is a Wiener process with correlations between the Wiener processes. The constructor is:\n\nCorrelatedWienerProcess(Γ,t0,W0,Z0=nothing;kwargs...)\nCorrelatedWienerProcess!(Γ,t0,W0,Z0=nothing;kwargs...)\n\nwhere Γ is the constant covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.CorrelatedWienerProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.CorrelatedWienerProcess!","text":"One can define a CorrelatedWienerProcess which is a Wiener process with correlations between the Wiener processes. The constructor is:\n\nCorrelatedWienerProcess(Γ,t0,W0,Z0=nothing;kwargs...)\nCorrelatedWienerProcess!(Γ,t0,W0,Z0=nothing;kwargs...)\n\nwhere Γ is the constant covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.SimpleWienerProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.SimpleWienerProcess","text":"The SimpleWienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\n\nUnlike WienerProcess, this uses the SimpleNoiseProcess and thus does not support adaptivity, but is slightly more lightweight.\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.SimpleWienerProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.SimpleWienerProcess!","text":"The SimpleWienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\n\nUnlike WienerProcess, this uses the SimpleNoiseProcess and thus does not support adaptivity, but is slightly more lightweight.\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.CompoundPoissonProcess","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.CompoundPoissonProcess","text":"https://www.math.wisc.edu/~anderson/papers/AndPostleap.pdf Incorporating postleap checks in tau-leaping J. Chem. Phys. 128, 054103 (2008); https://doi.org/10.1063/1.2819665\n\n\n\n\n\n","category":"type"},{"location":"noise_processes/#DiffEqNoiseProcess.CompoundPoissonProcess!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.CompoundPoissonProcess!","text":"https://www.math.wisc.edu/~anderson/papers/AndPostleap.pdf Incorporating postleap checks in tau-leaping J. Chem. Phys. 128, 054103 (2008); https://doi.org/10.1063/1.2819665\n\n\n\n\n\n","category":"type"},{"location":"noise_processes/#Bridges","page":"Classic Noise Processes","title":"Bridges","text":"","category":"section"},{"location":"noise_processes/","page":"Classic Noise Processes","title":"Classic Noise Processes","text":"BrownianBridge\nBrownianBridge!\nDiffEqNoiseProcess.GeometricBrownianBridge\nDiffEqNoiseProcess.GeometricBrownianBridge!\nDiffEqNoiseProcess.CompoundPoissonBridge\nDiffEqNoiseProcess.CompoundPoissonBridge!","category":"page"},{"location":"noise_processes/#DiffEqNoiseProcess.BrownianBridge","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.BrownianBridge","text":"A BrownianBridge process is a Wiener process with a pre-defined start and end value. This process is distribution exact and back be back interpolated exactly as well. The constructor is:\n\nBrownianBridge(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\nBrownianBridge!(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\n\nwhere W(t0)=W₀, W(tend)=Wend, and likewise for the Z process if defined.\n\n\n\n\n\n","category":"function"},{"location":"noise_processes/#DiffEqNoiseProcess.BrownianBridge!","page":"Classic Noise Processes","title":"DiffEqNoiseProcess.BrownianBridge!","text":"A BrownianBridge process is a Wiener process with a pre-defined start and end value. This process is distribution exact and back be back interpolated exactly as well. The constructor is:\n\nBrownianBridge(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\nBrownianBridge!(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)\n\nwhere W(t0)=W₀, W(tend)=Wend, and likewise for the Z process if defined.\n\n\n\n\n\n","category":"function"}]
}
